---
title: "Rustè¯­è¨€å­¦ä¹ "
author: "Gang R"   
description : "Rustè¯­è¨€åŸºç¡€å­¦ä¹ "     
date: 2022-03-12T21:21:08+08:00
draft: false
tags:    
  - Rust              
  - ç¼–ç¨‹è¯­è¨€

categories:    
  - ç¼–ç¨‹è¯­è¨€ 
keywords:    
  - Rust
---

è®°å½•å­¦ä¹ Rustè¿‡ç¨‹ä¸­äº§ç”Ÿçš„ä»£ç ä¸éƒ¨åˆ†ç¬”è®°ã€‚

# Rust

## å®‰è£…

ç•¥

## Hello world

 

1. æ–°å»ºä¸€ä¸ªæ–‡ä»¶å¤¹

2. åˆ›å»ºmain.rsæ–‡ä»¶

3. ç¼–å†™ä»£ç 

   ```rust
   fn main(){
       println!("hello, world!");
   }
   ```

4. ç¼–è¯‘è¿è¡Œ

   ```
   rustc main.rs
   ```

## cargo

cargoæ˜¯ä¸€ä¸ªä¾èµ–ç®¡ç†å’Œç¼–è¯‘é›†æˆå·¥å…·ã€‚

```
cargo --version
```

### cargo åˆ›å»ºå·¥ç¨‹

```
cargo new hello_cargo
```

 cargo.tomlæ˜¯ä¾èµ–ç®¡ç†æ–‡ä»¶

ç¼–è¯‘

```
cargo build
```

è¿è¡Œ

```
.\target\debug\hello_cargo.exe
or 
cargo run
```

å‘å¸ƒ

```
cargo build --release
```

## Guessing Game

1. åˆ›å»ºæ–°é¡¹ç›®

   ```
   cargo new gassing_game
   ```

2. è¿è¡Œä¸€ä¸‹

   ```
   cargo run
   ```

3. è¾“å…¥è¾“å‡º

   ```rust
   //ä½¿ç”¨æ ‡å‡†åº“ï¼Œä¸éœ€è¦å¤–éƒ¨ä¾èµ–çš„åº“
   use std::io;
   fn main() {
       println!("Hello, world!");
       println!("Please input a number!");
   	//å®šä¹‰ä¸€ä¸ªå­—ç¬¦ä¸²å˜é‡
       let mut guess = String::new();
       //è·å–æ ‡å‡†è¾“å…¥
       io::stdin().read_line(&mut guess).expect("Failed to read line");
   	//æ‰“å°å˜é‡
       println!("your input is {}",guess);
   }
   
   ```

4. å¯¼å…¥éšæœºæ•°åº“

   ```
   //cargo.toml
   
   [dependencies]
   rand = "0.8.3"
   ```

5. æ›´æ–°é•œåƒæº

   ```
   åœ¨user/.cargo/config
   [source.crates-io]
   registry = "https://github.com/rust-lang/crates.io-index"
   replace-with = 'ustc'
   [source.ustc]
   registry = "git://mirrors.ustc.edu.cn/crates.io-index"
   ```

6. ç¼–è¯‘,ä¸‹è½½ä¾èµ–

   ```
   cargo build
   ```

7. ä½¿ç”¨éšæœºæ•°

   ```rust
   
   use rand::Rng;
   fn main() {
       let secret_number = rand::thread_rng().gen_range(1..101);
       println!("secret number is {}",secret_number);
   }
   ```

8. æ¯”è¾ƒ

   ```rust
   use std::io;
   use rand::Rng;
   use std::cmp::Ordering;
   fn main() {
       println!("Hello, world!");
       let secret_number = rand::thread_rng().gen_range(1..101);
       println!("secret number is {}",secret_number);
       println!("Please input a number!");
       let mut guess = String::new();
       io::stdin().read_line(&mut guess).expect("Failed to read line");
       let guess:u32 = guess.trim().parse().expect("please input a number!");
       println!("You guessed {}",guess);
       match guess.cmp(&secret_number) {
           Ordering::Less => println!("too small!"),
           Ordering::Greater => println!("too big!"),
           Ordering::Equal => println!("You win!"),
       }
   
   }
   
   ```

9. å¾ªç¯

   ```rust
   use std::io;
   use rand::Rng;
   use std::cmp::Ordering;
   fn main() {
       println!("Hello, world!");
       let secret_number = rand::thread_rng().gen_range(1..101);
       // println!("secret number is {}",secret_number);a
       loop {
           println!("Please input a number:");
           let mut guess = String::new();
           io::stdin().read_line(&mut guess).expect("Failed to read line");
           let guess:u32 = guess.trim().parse().expect("please input a number!");
           println!("You guessed {}",guess);
           match guess.cmp(&secret_number) {
               Ordering::Less => println!("too small!"),
               Ordering::Greater => println!("too big!"),
               Ordering::Equal => {
                   println!("You win!");
                   break;
               }
           }
       }
   }
   
   ```




## å˜é‡

1. åˆ›å»ºå˜é‡é¡¹ç›®

   ```
   cargo new variables
   ```

2. æœªåŠ mutçš„å˜é‡ä¸å¯ä¿®æ”¹å€¼

   ```rust
   fn main() {
       println!("Hello, world!");
       let mut x = 6;
       println!("x is {}",x);
       x=7;
       println!("x is {}",x);
   }
   
   ```

3. å¸¸é‡

   ```rust
       const MAX_VALUE:i32 = 100;
       println!("max value is {}",MAX_VALUE);
   ```

4. shadow

   ```rust
       let y = 4;
       let y = y +3;
       println!("y is {}",y);//7
       {
           let y = y +2;
           println!("y is {}",y);//9
       }
       println!("y is {}",y);//7
   
       let str = "hello world";
       let str = str.len();
       println!("str's len is {}",str);
   ```





## Data Types

```rust
 let x = "46".parse().expect("not a number!");//illegal
 let x:i32 = "46".parse().expect("not a number!");
```

### integer

![image-20220129120123860](http://imgs.iprivacy.top/MyNoteBook/ComputerLanguguages/Rust/image-20220129120123860.png)

### float

é»˜è®¤64ä½



### bool



### char

å¯ä»¥æœ‰è¡¨æƒ…

```rust
let em = 'ğŸ†’';
```



### Tuple

```rust
let tup = (1,2.3,'h');
let (x,y,z) = tup;
println!("x:{},y:{},z:{}",tup.0,tup.1,tup.2);
```

### Array

```rust
let arr = [1,2,3,4,5];
let arr:[i32;5] = [1,2,3,4,5];
let arr = [0;100];//100 ä¸ª 0
```

### Never

ä¸€ç§æ•°æ®ç±»å‹ï¼Œä½¿ç”¨ï¼è¡¨ç¤ºï¼Œç”¨äºæ°¸è¿œä¸å¯èƒ½æœ‰è¿”å›å€¼çš„å‡½æ•°ï¼›

```rust
#![feature(never_type)]
fn foo()->i32 {
    let x: ! = {
        return 123
    };
}
```



### åŠ¨æ€ç±»å‹



### é›¶ç±»å‹

å¤§å°ä¸ºé›¶ZSTï¼Œç©º

#### åº•ç±»å‹

Neverçš„å®ç°ï¼Œæ— 

## Function

```rust
fn add(a:i32,b:i32)->i32{
    let a = {
        let a = 1;
        a+1
    };
    a
}
```



## control flow

### if

ç±»å‹ä¸€è‡´ï¼›

conditionåªèƒ½æ˜¯boolå€¼

å¤šäº2ä¸ªelse if ä½¿ç”¨matchä»£æ›¿

```rust
fn main() {
    println!("Hello, world!");
    let condition = true;
    if condition{
        println!("condition is true!");
    }else {
        println!("condition is false!");
    }
}

```

```
let x = if condition { 6 } else {"six"};//ç±»å‹ä¸ä¸€æ ·ï¼Œç¼–è¯‘é”™è¯¯
let x = if condition { 6 } else {7};
```





### loop

loopå‰é¢å¯ä»¥æœ‰æ ‡å·

breakåªè·³å‡ºä¸€å±‚ã€

```rust
fn test_loop(){
    let mut count = 0;

    'flag: loop {
        println!("count is {}",count);
        let mut remainder = 10;
        loop {
            println!("remainder = {}",remainder);
            if remainder == 9 {
                break;
            }
            if count ==2 {
                break 'flag;
            }
            remainder -= 1; 
        }
        count+=1;
    }
    println!("end count is {}",count);
}
```



### while

while trueä¸è¡Œ,æ§åˆ¶æµåˆ†æã€‚

```rust
fn while_true(x:i32)->i32{
    while true {
        return x+1;
    }
    x//resolve
}
```



```rust
fn test_while(){
    let mut iter = 3;
    while iter > 0 {
        println!("iter is {}",iter);
        iter -= 1;
    }
}
```

### for

æœ¬è´¨æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ã€‚

```rust
fn test_for(){
    let  a = [0;3];
    for e in a {
        println!("{}",e);
    } 
 
    for e in (1..4).rev() {
        println!("{}",e);
    }
}
```

## ownership

æ‹¥æœ‰æƒæ˜¯é’ˆå¯¹å †åŒºçš„æ•°æ®æ¥è¯´çš„ã€‚

å¯¹äºåŸºæœ¬æ•°æ®ç±»å‹éƒ½æ˜¯å­˜åœ¨æ ˆä¸Šï¼Œæ‰€ä»¥æ— å…³æ‹¥æœ‰æƒ

```rust
fn main() {
    println!("Hello, world!");
    let x = 4;
    let y =x;
    println!("{}{}",x,y);
    let s = "hello";
    let s1 = s;
    let flag = true;
    let flag1 = flag;
}
```

å¯¹äºå †ä¸Šçš„æ•°æ®ï¼Œèµ‹å€¼ã€ä¼ å‚éƒ½ä¼šç§»äº¤æ‹¥æœ‰æƒï¼Œå¯¹äºè¿™ç§æ“ä½œå«åšmoveï¼Œ ã€‚

```rust
fn string_onwership(){
    let s = String::from("hello");
    let s1 = s;
    {
        let s2 = s1;
    }//s1,s2éƒ½ä¸å¯ç”¨äº†
    let s3 = gives_onwership();//s3å€Ÿç”¨äº†helloçš„æ‹¥æœ‰æƒ
    get_onwership(s3);//s3moveç»™äº†å‡½æ•°
    //s3ä¸å¯ç”¨äº†
}
fn gives_onwership()->String{
    let s = String::from("hello");
    s
}
fn get_onwership(s:String){
    let s1 = s;
}
```

### å¼•ç”¨

ä¸ç§»äº¤æ‹¥æœ‰æƒ

```rust
fn main() {
    println!("Hello, world!");
    let s = String::from("hello");
    println!("{}",get_len(&s)); 
    println!("{}",s);
}

fn get_len(s:&String)->usize{
    s.len()
}
```

```rust
fn main() {
    println!("Hello, world!");
    let s = String::from("hello");
    println!("{}",get_len(&s)); 
    println!("{}",s);
    let mut s1 = String::from("hello");
    change(&mut s1);
    println!("{}",s1);
}

fn change(s:&mut String){
    s.push_str("hello");
}
```

å¯å˜å¼•ç”¨åªèƒ½æœ‰ä¸€æ¬¡ã€‚

ä¸å¯å˜å¼•ç”¨å¯ä»¥æœ‰æ— é™æ¬¡ã€‚

```rust

fn quote(){
    let mut s = String::from("hello");
    let s1 = &mut s;
    let s2 = &mut s;//é”™è¯¯
    println!("{}{}",s2,s1);
}
```

```rust
fn quote(){
    let mut s = String::from("hello");
    let s1 = &mut s;
    let s2 = &s1;
    println!("{}{}",s2,s1);
}
```

å¯å˜å˜é‡ä¸èƒ½åŒæ—¶å­˜åœ¨å¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨ï¼Œå¯ä»¥æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨ã€‚

```rust
fn quote1(){
    let mut my_str = String::from("A mutable string");
    let first_unmutable_reference = &my_str;
    let second_unmutable_reference = &my_str;
     println!("{} {}", first_unmutable_reference, second_unmutable_reference);
}
```

å¯å˜å˜é‡ä¸èƒ½åŒæ—¶å­˜åœ¨å¤šä¸ªå¯å˜å¼•ç”¨ã€‚

å¯å˜å¼•ç”¨ç§»äº¤æ‰€æœ‰æƒã€‚

å¼•ç”¨çš„ä¼ é€’å«å€Ÿç”¨ã€‚

### åˆ‡ç‰‡

```rust
fn slice(){
    let s = String::from("hello world");
    let s1 = &s[1..2];
}
```



## Struct

ä¸‰ç§

- æ­£å¸¸å…·åç»“æ„ä½“

- å…ƒç»„

  - NewType

    ```
    ä¸€ä¸ªå…ƒç»„ç»“æ„ä½“åªæœ‰ä¸€ä¸ªå­—æ®µçš„æ—¶å€™ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºNew Type æ¨¡å¼
    struct Interger(i32);
    type Int = i32;
    ```

  - ä¹Ÿå¯ä»¥ä½¿ç”¨type å…³é”®å­—ä¸ºä¸€ä¸ªç±»å‹åˆ›å»ºåˆ«å

- å•å…ƒç»“æ„ä½“ï¼šæ²¡æœ‰ä»»ä½•å­æ®µçš„ç»“æ„ä½“



define

```rust
struct Student {
    email:char,
    name:char,
    age:f64,
}
struct Color(i16,u32,String);
```

initial

```rust
let mut a = Student{
    email:String::from("123@163.com"),
    name:String::from("gre"),
    age:23.1,
};
```

```rust
let mut b = Student{
        name:String::from("hello"),
        ..a
};//æ­¤æ–¹æ³•ä¼šmove
```

è®¿é—®

```rust
println!("{}",a.age);
println!("{}",c.1);
```

### æ–¹æ³•

```rust
struct Rectangle{
    width:u32,
    height:u32,
}

impl Rectangle {
    fn area(&self)->u32{
        self.width * self.height
    }
}
let rect = Rectangle{
    width:10,
    height:10,
};
println!("{}", rect.area());
```

```rust
let squ = Rectangle::square(4);
println!("{}",squ.area());
```



## Enums 

```rust
enum IpAddr {
    V4(String),
    V6,
}
fn main() {
    let four = IpAddr::V4(String::from("127.0.0.1"));
    // println!("{}",four);
}

```

### option

Rustæ²¡æœ‰null

æä¾›äº†Optionï¼Œé¢„å¯¼å…¥äº†ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ã€‚

```rust
pub enum Option<T> {
    /// No value
    #[lang = "None"]
    #[stable(feature = "rust1", since = "1.0.0")]
    None,
    /// Some value `T`
    #[lang = "Some"]
    #[stable(feature = "rust1", since = "1.0.0")]
    Some(#[stable(feature = "rust1", since = "1.0.0")] T),
}
```

```rust
    let a:Option<i32> = Some(12);
    let b:i32 = 2;
    let c = a+b;//error ç±»å‹ä¸åŒ
```

### match

if let

while let



```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}
fn value_in_cents(coin:Coin)->u8{
    match coin {
        Coin::Penny=>1,
        Coin::Nickel=>5,
        Coin::Dime=>10,
        Coin::Quarter=>{
            20+5
        }
    }
}
fn plus_one(x:Option<i32>)->Option<i32>{
    match x {
        None => None,
        Some(i)=>Some(i+1),
    }
}
fn main() {
    println!("Hello, world!");
    println!("{}",value_in_cents(Coin::Nickel)); 
    plus_one(Some(3));
}

```

```rust
let v = 0u8;
match v {
    1 => println!("{}",1),
    _ => (),
}
```

```rust
let v = Some(0u8);
if let Some(3) = v {
    println!("three");
}
```



## æŒ‡é’ˆ

- åŸç”ŸæŒ‡é’ˆ
- å¼•ç”¨
- å‡½æ•°æŒ‡é’ˆ
- æ™ºèƒ½æŒ‡é’ˆ

### åŸç”ŸæŒ‡é’ˆ

åŸç”ŸæŒ‡é’ˆä¸å®‰å…¨ï¼Œéœ€è¦ä½¿ç”¨unsafeï¼Œä¸¤ç§

```
*const T
*mut T
```

```rust
fn main() {
    let mut x = 10;
    let ptr_x = &mut x as *mut i32;
    let y = Box::new(20);
    let ptr_y = &*y as *const i32;
    unsafe{
        *ptr_x += *ptr_y;
    }
    println!("x: {}",x);
}
```

Boxæ˜¯åœ¨å †ä¸Šåˆ›å»ºå†…å®¹ã€‚

### æ™ºèƒ½æŒ‡é’ˆ

éRustç‹¬æœ‰ï¼Œå€Ÿé‰´äºC++

Rusté»˜è®¤å°†å˜é‡åˆ†é…åˆ°æ ˆç©ºé—´ï¼Œä½¿ç”¨Boxå¯ä»¥åˆ†é…åˆ°å †ç©ºé—´ï¼Œå¹¶ä¸”å¯ä»¥è‡ªåŠ¨ææ„ã€‚

Box<T>,å¯ä»¥é€šè¿‡`*` è§£å¼•ç”¨è·å–T

æ™ºèƒ½æŒ‡é’ˆä¸æ­¢Box

```rust
#[derive(Debug)]
 struct Point{
     x:i32,
     y:i32,
 }

fn main() {
    let p1 = Point{x:12,y:13};
    let origin = Box::new(p1);
    let p2 = *origin;
    println!("{:?}",p2);    
}
```



## Package,Crate,Module



## é›†åˆ

- çº¿æ€§ï¼šå‘é‡ï¼ŒåŒç«¯é˜Ÿåˆ—ï¼Œé“¾è¡¨
- Key-Value:æ— åºå“ˆå¸Œè¡¨ï¼Œæœ‰åºå“ˆå¸Œè¡¨
- é›†åˆç±»å‹ï¼šæ— åºé›†åˆï¼Œæœ‰åºé›†åˆ
- ä¼˜å…ˆé˜Ÿåˆ—ï¼šäºŒå‰å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰

### vector

- æ ‡å‡†åº“æä¾›
- å¯ä»¥å­˜å‚¨å¤šä¸ªå€¼
- åªèƒ½å­˜å‚¨ç›¸åŒæ•°æ®ç±»å‹
- å€¼åœ¨å†…å­˜ä¸­è¿ç»­å­˜æ”¾

åˆ›å»º

```rust
fn main() {
    println!("Hello, world!");
    let v:Vec<i32> = Vec::new();
    let v = vec![1,2,3]; 
}
```

æ›´æ–°

è¦ä¹ˆè¯»ï¼Œè¦ä¹ˆå†™

```rust
let mut v = vec![1,2,3]; 
v.push(2);
v.push(3);
v.push(4);
```

è·å–

```rust
    let mut v = vec![1,2,3]; 
    v.push(2);
    v.push(3);
    v.push(4);
    let third:&i32 = &v[3];
    println!("The third element is {}",third);
    match v.get(3) {
        Some(third) => println!("The third element is {}",third),
        None => println!("None"),
    }
	let third:&i32 = &v[100];//panic
    println!("The third element is {}",third);
    match v.get(100) {//ok
        Some(third) => println!("The third element is {}",third),
        None => println!("None"),
    }
```

éå†

```rust
    let v = vec![1,2,3,4,5];
    for ele in &v {
        print!("{}",ele);
    }
    let mut v = v;
    for ele in &mut v{
        *ele += 5;
        println!("{}",ele);
    }
```

åˆ é™¤

- å‡ºä½œç”¨åŸŸå°±ä¼šåˆ é™¤

```

```

æ–¹ä¸åŒæ•°æ®ç±»å‹

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}
fn example(){
    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Float(3.2),
        SpreadsheetCell::Text(String::from("hello")),
    ];
}
```

### String

- Byteçš„é›†åˆ
- ä¸€äº›æ–¹æ³•
  - å°†byteè§£æä¸ºæ–‡æœ¬
- UTF-8

#### str

åˆ‡ç‰‡å½¢å¼str

#### åˆ›å»º

```
fn create(){
    let mut  s = String::new();
    let data = "initial contents";
    let s = data.to_string();
    let s1 = String::from("initial contents");
    let utf_char = String::from("ã“ã‚“ã«ã¡ã¯ã€ä¸–ç•Œ!");
    
}
```

#### æ›´æ–°

ç±»æ¯”vector

ä½¿ç”¨+ç±»ä¼¼addæ–¹æ³•

```rust
fn update(){
    let mut s = String :: from("foo");
    let str = String::from("bar");
    s.push_str(&str);
    s.push('l');
    println!("{}",str);
}
```

#### æ‹¼æ¥

```rust
fn cat(){
    let s1 = String::from("hello");
    let s2 = String::from("world");
    let s3 = s1 + &s2;
    println!("{}",s3);
    let s4 = format!("{}-{}",s2,s3);
    println!("{}",s4);
}
```

#### è®¿é—®

å­—ç¬¦ç°‡

```rust
fn read(){
    let s = String::from("hello world");
    let a = s[1];//error
}
```

```rust
fn read(){
    let s = String::from("hello world");
    // let a = s[1];
    let len = String::from("1234").len();//4
    let len = String::from("á–ƒá…á”¨á’ªá’»á’ªá•†á‘¦á‘á“„á‘¦").len();//33
    //Unicode æ ‡é‡å€¼
    println!("{}",len);
}
```

```rust
fn type_check(){
    let s = String::from("à¤¶à¥à¤­à¤¾à¤ƒ à¤¦à¥à¤¨à¤¿à¤¯à¤¾!");
    for b in s.bytes(){
        println!("{}",b);
    }
    for c in s.chars(){
        println!("{}",c);
    }
}
```

#### åˆ‡å‰²

```rust
fn slice(){
    let hello = String::from("à¤¶à¥à¤­à¤¾à¤ƒ à¤¦à¥à¤¨à¤¿à¤¯à¤¾!");
    let s = &hello[0..6];//4 panic, each char 3 bytes
    println!("{}",s);
}
```

### hashmap

- HashMap<K,V>

#### åˆ›å»º

- å †ä¸Š

```rust
use std::collections::HashMap;

fn create(){
    let mut scores:HashMap<String,i32> = HashMap::new();
    let mut scores = HashMap::new();
    scores.insert(String::from("age"),23);
}

```

```rust
fn create2(){
    let teams = vec![String::from("blue"),String::from("yellow")];
    let initial_score = vec![10,50];
    let scores:HashMap<_,_> = teams.iter().zip(initial_score.iter()).collect();
}
```

#### æ‰€æœ‰æƒ

- å¯¹äºå®ç°äº†copy traitçš„ç±»å‹ï¼Œå€¼ä¼šè¢«å¤åˆ¶åˆ°HashMapä¸­

- å¯¹äºæ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼ï¼ˆString),å€¼ä¼šç§»åŠ¨ï¼ˆmoveï¼‰ï¼Œæ‰€æœ‰æƒå½’HashMap

  ```rust
  fn ownership(){
      let key = String::from("jack");
      let value = String::from("32");
      let mut person = HashMap::new();
      // person.insert(key, value);
      // println!("{}{}",key,value);//error 
      person.insert(&key, &value);
      println!("{}{}",key,value);//ok
  }
  ```

#### è·å–

```rust
fn get(){
    let mut scores = HashMap::new();
    scores.insert(String::from("blue"), 10);
    scores.insert(String::from("yellow"), 50);
    let team_name = String::from("blue");
    let score = scores.get(&team_name);
    match score {
        Some(s) => println!("score is {}",s),
        None => println!("team not exist"),
    }
}
```

#### éå†

```rust

fn traverse(){
    let mut scores = HashMap::new();
    scores.insert(String::from("blue"), 10);
    scores.insert(String::from("yellow"), 50);
    for (k,v) in &scores{
        println!("{}-{}",k,v);
    }
}
```

#### æ›´æ–°

- HashMapå¤§å°å¯å˜
- æ¯ä¸ªkå¯¹åº”ä¸€ä¸ªv
- æ›´æ–°
  - å­˜åœ¨ï¼Œæ›¿æ¢ï¼Œä¿ç•™ï¼Œåˆå¹¶
  - ä¸å­˜åœ¨ï¼Œæ·»åŠ 

```rust
fn update(){
    let mut scores = HashMap::new();
    scores.insert(String::from("blue"), 10);
    scores.insert(String::from("blue"), 25);
    println!("{:?}",scores);
    scores.entry(String::from("yellow")).or_insert(50);
    scores.entry(String::from("blue")).or_insert(50);
    println!("{:?}",scores);//{"blue": 25, "yellow": 50}
}
```

## é”™è¯¯å¤„ç†

- ç¼–è¯‘é”™è¯¯å¹¶å¤„ç†
- é”™è¯¯åˆ†ç±»
  - å¯æ¢å¤ï¼Œæ–‡ä»¶æœªæ‰¾åˆ°
  - ä¸å¯æ¢å¤ï¼Œè¶…å‡ºindex
- Rustæ²¡æœ‰å¼‚å¸¸å¤„ç†æœºåˆ¶
  - å¯æ¢å¤ï¼ŒResult
  - ä¸å¯æ¢å¤ï¼španicï¼å®

### panicï¼

å½“panicï¼å®æ‰§è¡Œæ—¶ï¼š

- ç¨‹åºæ‰“å°é”™è¯¯ä¿¡æ¯
- å±•å¼€unwindï¼Œæ¸…ç†è°ƒç”¨æ ˆStack
- é€€å‡ºç¨‹åº

å¯ä»¥é€‰æ‹©ç»ˆæ­¢è°ƒç”¨æ ˆï¼š

- ä¸æ¸…ç†ï¼Œç›´æ¥é€€å‡º
- å†…å­˜éœ€è¦osè¿›è¡Œæ¸…ç†

è®©ç¨‹åºæ–‡ä»¶æ›´å°ï¼Œå¯ä»¥æŠŠå±•å¼€æ”¹ä¸ºç»ˆæ­¢ï¼š

cargo.tomlçš„profile

- panic = â€˜abortâ€™

```toml
[profile.release]
panic = 'abort'
```

é”™è¯¯ä¿¡æ¯

```
RUST_BACKTRACE=1
```

```rust
fn main() {
    // panic!("crash and burn");
    let v = vec![1,2,3];
    v[22];
    println!("Hello, world!");
}

```

ä¸å¸¦â€“release



### Result



```rust
pub enum Result<T, E> {
    Ok(#[stable(feature = "rust1", since = "1.0.0")] T),
    Err(#[stable(feature = "rust1", since = "1.0.0")] E),
}
```

```rust
use  std::fs::File;
fn example(){
    let f = File::open("hello.txt");
    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("error opening file {:?}",error);
        }
    };
}
```

```rust
use std::io::ErrorKind;
fn example2(){
    let f = File::open("hello.txt");
    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt"){
                Ok(fc) => fc,
                Err(e) => panic!("error creating file {:?}",e),
            },
            other_error => panic!("Error opening the file {:?}",other_error),
            
        }
    };
}
```

 é—­åŒ…

```rust
fn closure(){
    let f = File::open("hello.txt").unwrap_or_else(|error|{
        if error.kind() == ErrorKind::NotFound{
            File::create("hello.txt").unwrap_or_else(|error|{
                panic!("Error create file:{:?}",error);
            })
        }else {
            panic!("Error opening file {:?}",error);
        }
    });
}
```

#### unwrap

matchè¡¨è¾¾å¼çš„ä¸€ä¸ªå¿«æ·æ–¹æ³•ï¼›

- å¦‚æœæ˜¯okå°±è¿”å›okçš„ç»“æœ
- errè¿”å›panicï¼å®

```rust
fn example3(){
    let f = File::open("hello.txt").unwrap();
}
```

#### expect

å¯ä»¥æŒ‡å®šé”™è¯¯ä¿¡æ¯

```rust
fn example4(){
    let f = File::open("hello.txt").expect(&String::from("æ— æ³•æ‰“å¼€æ–‡ä»¶"));
}
```



### ä¼ æ’­é”™è¯¯

```rust
let res = example5();
use std::io::Read;
use std::io;
fn example5() -> Result<String,io::Error>{
    let f = File::open("hello.txt");
    let mut  f = match f {
        Ok(f) =>f,
        Err(e) => return Err(e),
    };
    let mut s = String::new();
    match f.read_to_string(&mut s) {
        Ok(_)=>Ok(s),
        Err(e)=>Err(e),
    }
}
```

ï¼Ÿé”™è¯¯ä¼ æ’­å¿«æ·æ–¹å¼

```rust
fn example6() -> Result<String,io::Error>{
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
```

ï¼Ÿä¸fromå‡½æ•°ï¼Œå¯ä»¥æœ‰é”™è¯¯è½¬æ¢ã€‚

ä¼˜åŒ–

```rust
fn example7()-> Result<String,io::Error>{
    let mut s = String::new();
    File::open("hello.txt")?.read_to_string(&mut s)?;
    Ok(s)
}
```

#### ä»€ä¹ˆæ—¶å€™ç”¨panic

åŸåˆ™

- åœ¨å®šä¹‰ä¸€ä¸ªå¯èƒ½å¤±è´¥çš„å‡½æ•°æ˜¯ä¼˜å…ˆè€ƒè™‘Result
- å¦åˆ™panic

åœºæ™¯

- æ¼”ç¤ºæ¦‚å¿µ
- åŸå‹ä»£ç ï¼šunwrapã€expect
- æµ‹è¯•

ä¸€å®šæ˜¯okæ—¶å¯ä»¥ä½¿ç”¨unwrap

- ä¼ å…¥æ— æ„ä¹‰å‚æ•°æ—¶
- è°ƒç”¨å¤–éƒ¨ä¸å¯æ§ä»£ç 
- å¯é¢„æœŸçš„ç”¨Result
- å€¼éªŒè¯



## æ³›å‹ï¼ŒTrait,ç”Ÿå‘½å‘¨æœŸ

æå–å‡½æ•°æ¶ˆé™¤é‡å¤ä»£ç 

### æ³›å‹

æé«˜å¤ç”¨èƒ½åŠ›

ç›¸å¯¹äºæ¨¡æ¿

#### æ³›å‹å‡½æ•°

```rust
fn largest<T>(list:&[T])->T{
    let mut largest = list[0];
    for &item in list{
        if item > largest{ // todo 
            largest = item;
        }
    }
    largest
}
```

#### structæ³›å‹

```rust
struct Point<T>{
    x:T,
    y:T,
}
fn main() {
    println!("Hello, world!");
    let int_type = Point{x:3,y:4};
    let float_type = Point{x:4.1,y:4.5}; 
}
```

å•æ€åŒ–

### Trait

é›¶æˆæœ¬æŠ½è±¡ã€‚

æŠ½è±¡çš„å®šä¹‰å…±äº«çš„è¡Œä¸º

ç±»ä¼¼æ¥å£ã€‚

#### å®šä¹‰

```rust
pub trait Summary {
    fn summarize(&self)->String;
}
```

#### å®ç°

```rust
pub struct NewsArticle{
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}
impl Summary for NewsArticle {
    fn summarize(&self)->String{
        format!("{},by {} ({})",self.headline,self.author,self.location)
    }
}
```

#### é»˜è®¤å®ç°

```rust
pub trait Summary {
    // fn summarize(&self)->String;
    fn summarize(&self)->String{
        String::from("Read more ..")
    }
}
```

#### ä½œä¸ºå‚æ•°

```rust
pub fn notify(item : impl Summary) {
    print!("news:{}",item.summarize());
}
pub fn notify1<T:impl Summary + Display>(item:T){
    print!("news:{}",item.summarize());
}
```

```rust
pub fn notify2<T,U>(a:T,b:U) -> String 
where
    T:Summary+Display,
    U:Clone+Debug,
{
    print!("news:{}",a.summarize());
}
```

#### ä½œä¸ºè¿”å›

```rust
pub fn notify(s:&str)->impl Summary{
    NewsArticle{
        headline: String::from("éœ‡æƒŠï¼ä¸€ç”·å­ç«Ÿç‹¬è‡ªç©ææ€–æ¸¸æˆ"),
        location: String::from("å››å·"),
        author: String::from("å¼ ä¸‰"),
        content: String::from("ssssss"),
    };
}
```

```rust
fn largest<T:PartialOrd + Copy>(list:&[T])->T{
    let mut largest = list[0];
    for &item in list{
        if item > largest{ // todo 
            largest = item;
        }
    }
    largest
}
```



### ç”Ÿå‘½å‘¨æœŸ

- æ¯ä¸ªå¼•ç”¨éƒ½æœ‰ç”Ÿå‘½å‘¨æœŸ
- å¤§å¤šæ•°æƒ…å†µæ˜¯éšå¼çš„ï¼Œå¯è¢«æ¨æ–­çš„
- æ‰‹åŠ¨æ ‡å¿—

å€Ÿç”¨æ£€æŸ¥å™¨

#### æ ‡æ³¨

ä¸å½±å“åŸç”Ÿå‘½å‘¨æœŸ 

```rust
fn main() {
    let str1 = String::from("adbcd");
    let str2 = "123456";
    println!( "{}",longest(str1.as_str(), str2));
}

fn longest<'a>(x:&'a str,y:&'a str)->&'a str{
    if x.len() >y.len(){
        x
    }else {
        y
    }
}

```



## æµ‹è¯•

æµ‹è¯•æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå¦å¼€ä¸€ä¸ªçº¿ç¨‹ï¼Œå¦‚æœæ²¡æœ‰panicå°±é€šè¿‡

3Aæ“ä½œï¼š

- å‡†å¤‡æ•°æ®
- è¿è¡Œä»£ç 
- æ–­è¨€ç»“æœ



### æµ‹è¯•å‡½æ•°

åŠ ä¸Šæ ‡å¿—

cargo testè¿›è¡Œæµ‹è¯•

åˆ›å»º

```
cargo new add â€“lib
```

ä»£ç 

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}

```

è¿è¡Œ

```
cargo test
```

å¤±è´¥æµ‹è¯•æ ·ä¾‹

```rust
#[test]
fn another(){
	panic!("eeeeerror");
}
```

### æ–­è¨€

assertï¼åˆ¤æ–­çŠ¶æ€æ˜¯å¦ä¸ºç©º

```rust
#[test]
fn is_true(){
    assert!(ret());
}
```

assert_eq!

assert_nq!

```rust
#[test]
fn test_add_two(){
    assert_eq!(5,add_two(4));
}
```

### should_panic

å‘é€ææ…Œé€šè¿‡æµ‹è¯•

```rust
#[test]
#[should_panic(expected = "aa")]
fn another(){
    panic!("aba");
}
```

### æµ‹è¯•ä½¿ç”¨Result

```rust
#[test]
fn equal()->Result<(),String>{
    if 2+2 == 5{
        Ok(())
    }
    else {
        Err(String::from("error"))
    }
}
```

### test-thread

### æ˜¾ç¤ºè¾“å‡º

å¤±è´¥printlnä¼šæ‰“å°ï¼Œå¦åˆ™ä¸ä¼šã€‚

å¯ä»¥ä½¿ç”¨

```
--show-output
```

### æŒ‰åç§°è¿è¡Œæµ‹è¯•

```
cargo test add_two
cargo test add
```

### å¿½ç•¥æµ‹è¯•

```
#[ingore]
```

```
cargo test --ingored
```

### æµ‹è¯•åˆ†ç±»

- å•å…ƒæµ‹è¯•
- é›†æˆæµ‹è¯•

#### å•å…ƒæµ‹è¯•

```rust
#[cfg(test)]
mod tests {

}
```

æµ‹è¯•ç§æœ‰å‡½æ•°

```
å¼•å…¥
use super::*

```

#### é›†æˆæµ‹è¯•

åˆ›å»ºtestsç›®å½•

ç›®å½•ä¸‹çš„æ–‡ä»¶è¢«ç‰¹æ®Šå¯¹å¾…ã€‚

```rust
use adder;

#[test]
fn it_add_two(){
    assert_eq!(4,adder::add_two(3))
}
```

å…¶ä¸­çš„å¸®åŠ©å‡½æ•°

åˆ›å»ºä¸€ä¸ªcommonæ–‡ä»¶å¤¹

æ–‡ä»¶å¤¹ä¸‹é¢æ–¹å¸®åŠ©å‡½æ•°ã€‚



## å®ä¾‹-å‘½ä»¤è¡Œç¨‹åº

grepå·¥å…·

### æ¥å—å‚æ•°

```rust
use std::env; //collect


fn main() {
    let args: Vec<String> = env::args().collect();
    let query = &args[1];
    let filename = &args[2];
    println!("worlds: {:?}",query);
    println!("file: {:?}",filename);
}

```

### è¯»å–æ–‡ä»¶

```rust
use std::env; //collect
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();
    let query = &args[1];
    let filename = &args[2];
    
    println!("worlds: {:?}",query);
    println!("file: {:?}",filename);
    let contents = fs::read_to_string(filename).expect("Something went wrong reading the file");
    println!("{}",contents);
}

```

### é‡æ„ï¼šæ”¹è¿›æ¨¡å—å’Œé”™è¯¯å¤„ç†

```rust
use std::env; //collect
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();
    let config = Config::new(&args);
    let contents = fs::read_to_string(config.filename).expect("Something went wrong reading the file");
    println!("{}",contents);
}
struct Config{
    query:String,
    filename:String,
}
impl Config {
    fn new(args:&[String]) -> Config{
        let query = args[1].clone();
        let filename = args[2].clone();
        Config{query,filename}
    }
}

```

åˆ›å»ºlib.rs

```rust
use std::fs;
use std::error::Error;


pub struct Config{
    query:String,
    filename:String,
}
impl Config {
    pub fn new(args:&[String]) -> Result<Config,&'static str>{
        if args.len() < 3{
            return  Err("not enough aruguments");
        }
        let query = args[1].clone();
        let filename = args[2].clone();
        Ok(Config{query,filename})
    }
}

pub fn run(config:Config) -> Result<(),Box<dyn Error>>{
    let contents = fs::read_to_string(config.filename)?;
    println!("file contents {}",contents);
    Ok(())
}
```

main.rs

```rust
use std::env; //collect
use std::process;
use grep_project;

fn main() {
    let args: Vec<String> = env::args().collect();
    let config = grep_project::Config::new(&args).unwrap_or_else(|error|{
        println!("Problem parsing arguments:{}",error);
        process::exit(1);
    });
    if let Err(e) = grep_project::run(config){
        println!("Application error:{}",e);
        process::exit(1);
    }
}
```



### ä½¿ç”¨TDDå¼€å‘åº“åŠŸèƒ½

Test Driven Development

```rust
use std::fs;
use std::error::Error;


pub struct Config{
    query:String,
    filename:String,
}
impl Config {
    pub fn new(args:&[String]) -> Result<Config,&'static str>{
        if args.len() < 3{
            return  Err("not enough aruguments");
        }
        let query = args[1].clone();
        let filename = args[2].clone();
        Ok(Config{query,filename})
    }
}

pub fn run(config:Config) -> Result<(),Box<dyn Error>>{
    let contents = fs::read_to_string(config.filename)?;
    for line in search(&config.query, &contents){
        println!("{}",line);
    }
    Ok(())
}
pub fn search<'a>(query:&str,contents:&'a str)->Vec<&'a str>{
    let mut results = Vec::new();
    for line in contents.lines(){
        if line.contains(query){
            results.push(line);
        }
    }
    results
}
#[cfg(test)]
mod tests{
    use super::*;
    #[test]
    fn on_result(){
        let query = "duct";
        let contents = "\
Rust:
safe,fast,productive.
Pick three";
        assert_eq!(vec!["safe,fast,productive."],search(query,contents));
    }
}
```



### ä½¿ç”¨ç¯å¢ƒå˜é‡

```rust
use std::fs;
use std::error::Error;
use std::env; //collect

pub struct Config{
    pub query:String,
    pub filename:String,
    pub case_sensitive:bool,
}
impl Config {
    pub fn new(args:&[String]) -> Result<Config,&'static str>{
        if args.len() < 3{
            return  Err("not enough aruguments");
        }
        let query = args[1].clone();
        let filename = args[2].clone();
        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();
        Ok(Config{query,filename,case_sensitive})
    }
}

pub fn run(config:Config) -> Result<(),Box<dyn Error>>{
    let contents = fs::read_to_string(config.filename)?;
    if config.case_sensitive{
        for line in search(&config.query, &contents){
            println!("{}",line);
        }
    }else {
        for line in search_case_insensitive(&config.query, &contents){
            println!("{}",line);
        }
    }
    
    Ok(())
}
pub fn search<'a>(query:&str,contents:&'a str)->Vec<&'a str>{
    let mut results = Vec::new();
    for line in contents.lines(){
        if line.contains(query){
            results.push(line);
        }
    }
    results
}
pub fn search_case_insensitive<'a>(query:&str,contents:&'a str)->Vec<&'a str>{
    let mut results = Vec::new();
    let query = query.to_lowercase();
    for line in contents.lines(){
        if line.to_lowercase().contains(&query){
            results.push(line);
        }
    }
    results
}
#[cfg(test)]
mod tests{
    use super::*;
    #[test]
    fn case_sensitive(){
        let query = "duct";
        let contents = "\
Rust:
safe,fast,productive.
Pick three
Duck tape"
;
        assert_eq!(vec!["safe,fast,productive."],search(query,contents));
    }
    #[test]
    fn case_insensitive(){
        let query = "rUsT";
        let contents = "\
Rust:
safe,fast,productive.
Pick three
Duck tape
Trust me"
;
        assert_eq!(vec!["Rust:","Trust me"],search_case_insensitive(query,contents));
    }
}
```



### å°†é”™è¯¯æ¶ˆæ¯å†™å…¥æ ‡å‡†é”™è¯¯

```rust
use std::env; //collect
use std::process;
use grep_project;

fn main() {
    let args: Vec<String> = env::args().collect();
    let config = grep_project::Config::new(&args).unwrap_or_else(|error|{
        eprintln!("Problem parsing arguments:{}",error);
        process::exit(1);
    });
    if let Err(e) = grep_project::run(config){
        eprintln!("Application error:{}",e);
        process::exit(1);
    }
   
}


```





## é—­åŒ…

ä¹Ÿå«åŒ¿åå‡½æ•°ï¼›

å¯ä»¥ä½œä¸ºè¿”å›å€¼ã€å‚æ•°ï¼›

å¯ä»¥æ•è·ç¯å¢ƒå˜é‡ï¼›

å¯ä»¥æ¨æ–­è¾“å…¥ç±»å‹ï¼Œè¾“å‡ºç±»å‹ï¼›

```rust
use std::thread;
use std::time::Duration;
fn main() {
    println!("Hello, world!");
    get_schdule(20);
}
fn get_schdule(time:u32){
    let compute = |args:u32|{
        println!("slowly ....");
        thread::sleep(Duration::from_secs(2));
        args
    };
    if time>10{
        println!("done  .. {}",compute(time));
    }else {
        println!("done .. {}",compute(time));
    }

}
```

ç±»å‹æ¨æ–­ã€‚

### ç»“æ„ä½“é—­åŒ…

Fn Traitç”±æ ‡å‡†åº“æä¾›

æ‰€æœ‰é—­åŒ…å¾—å®ç°ä»¥ä¸‹ä¹‹ä¸€ï¼š

- Fn
- FnMut
- FnOnce

```rust
use std::thread;
use std::time::Duration;
fn main() {
    println!("Hello, world!");
    get_schdule(20);
}

struct  Cacher<T>
where T:Fn(i32)->i32
{
    calculation:T,
    value:Option<i32>,
}
impl <T> Cacher<T>
where T:Fn(i32)->i32
{
    fn new(calculation:T)->Cacher<T>{
        Cacher{
            calculation,
            value:None,
        }
    }
    fn value(&mut self,arg:i32)->i32{
        match self.value {
            Some(v) =>v,
            None=>{
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}

fn get_schdule(time:i32){
    
    let mut compute = Cacher::new(|args:i32|{
        println!("slowly ....");
        thread::sleep(Duration::from_secs(2));
        args
    });
    if time>10{
        println!("done  .. {}",compute.value(time));
    }else {
        println!("done .. {}",compute.value(time));
    }

}
```

Cacheé™åˆ¶ï¼šåªèƒ½ä¿ç•™ä¸€ä¸ªå€¼ï¼Œç±»å‹é—®é¢˜

ä½¿ç”¨å“ˆå¸Œmapè§£å†³ï¼›ä½¿ç”¨æ¨¡æ¿

```rust
use std::thread;
use std::time::Duration;
use std::collections::HashMap;
fn main() {
    println!("Hello, world!");
    get_schdule(20);
    let mut compute = Cacher::new(|args:i32|args);
    println!("{}", compute.value(1));
    println!("{}", compute.value(2));
 
}

struct  Cacher<T>
where T:Fn(i32)->i32
{
    calculation:T,
    value:HashMap<Option<i32>,i32>,
}
impl <T> Cacher<T>
where T:Fn(i32)->i32
{
    fn new(calculation:T)->Cacher<T>{
        Cacher{
            calculation,
            value:HashMap::new(),
        }
    }
    fn value(&mut self,arg:i32)->i32{
        match self.value.get(&Some(arg)){
            Some(v) => *v,
            None =>{
                let v = (self.calculation)(arg);
                self.value.insert(Some(arg), v);
                v
            }
        }  
    }
}

```

### ç¯å¢ƒæ•è·

å‡½æ•°ä¸èƒ½æ•è·ç¯å¢ƒï¼Œæ•è·éœ€è¦æ¶ˆè€—å†…å­˜ã€‚

- å–å¾—æ‰€æœ‰æƒï¼šFnOnce

  ```rust
  
  ```

- å–å¾—å¯å˜å€Ÿç”¨ï¼šFnMute

  ```rust
  
  ```

- ä¸å¯å˜å€Ÿç”¨ï¼šFn

  ```rust
  
  ```



ä½¿ç”¨moveå¯ä»¥ç§»åŠ¨æ‰€æœ‰æƒï¼Œå¤šç”¨äºå¤šçº¿ç¨‹

#### filter

è¿‡æ»¤æ¡ä»¶ä¸ºfalseçš„å€¼ã€‚

ä¿ç•™æ¡ä»¶ä¸ºtrueçš„å€¼ã€‚

```rust
#[derive(Debug)]
struct Shoe{
    size:i32,
    style:String,
}
fn shoes_in_my_szie(shoes:Vec<Shoe>,shoe_size:i32)->Vec<Shoe>{
    shoes.into_iter().filter(|x| x.size == shoe_size).collect()
}
fn test(){
    let v = vec![
        Shoe{
            size:10,
            style:String::from("sport"),
        },
        Shoe{
            size:12,
            style:String::from("releax"),
        },
        Shoe{
            size:10,
            style:String::from("clap"),
        },
    ];
    let in_my_size = shoes_in_my_szie(v,10);
    for e in in_my_size.iter(){
        println!("{:#?}",e);
    }
}
```



## è¿­ä»£å™¨

- æƒ°æ€§çš„

```rust
let v1 = vec![1,2,3];
let v1_iter = v1.iter();
for val in v1_iter{
    println!("{}",val);
}
```

### Iterator trait

æ‰€æœ‰è¿­ä»£å™¨éƒ½å®ç°äº† Iterator trait

è¦æœ‰ï¼š

- è¿”å›ï¼Œitem
- å®ç°ï¼Œnext->å…ƒç´ çš„ä¸å¯å˜å¼•ç”¨

into_iterï¼Œå–å¾—æ‰€æœ‰æƒ

iter_mutï¼Œå¯å˜å¼•ç”¨



### è¿­ä»£å™¨çš„äº§ç”Ÿä¸æ¶ˆè´¹

å¿…é¡»å®ç°nextï¼Œæ˜¯æ¶ˆè€—å‹çš„ã€‚ä¾‹å¦‚ï¼šsum

è¿­ä»£å™¨é€‚é…å™¨ï¼Œæ˜¯ç”Ÿäº§å‹çš„ã€‚ä¾‹å¦‚map



### è‡ªå®šä¹‰

```rust
struct Counter{
    count:u32,
}
impl Counter {
    fn new()->Counter{
        Counter{
            count:0
        }
    }
}
impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) ->Option<Self::Item>{
        if self.count < 5{
            self.count +=1;
            Some(self.count)
        }else {
            None                          
        }
    }
}
fn test_diy(){
    let mut counter = Counter::new();
    for i in (0..6){
        println!("{:?}",counter.next());
    }
}
```

### å¾ªç¯ä¸è¿­ä»£å™¨

è¿­ä»£å™¨ä¼šæ›´å¿«ä¸€ç‚¹ã€‚

ä¸äº§ç”Ÿé¢å¤–å¼€é”€ã€‚



## å‘å¸ƒ





## æ™ºèƒ½æŒ‡é’ˆ

æŒ‡é’ˆï¼šæŒ‡å‘å˜é‡åœ¨å†…å­˜ä¸­çš„åœ°å€

Rustä¸­å¸¸ç”¨çš„æŒ‡é’ˆæ˜¯å¼•ç”¨

- ä½¿ç”¨&
- å€Ÿç”¨å®ƒæŒ‡å‘çš„å€¼
- æ²¡æœ‰é¢å¤–å¼€é”€

### å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆ

- è®°å½•å¼•ç”¨è€…çš„æ•°é‡ï¼Œè®©ä¸€ä»½æ•°æ®å¤šä¸ªäººåŒæ—¶æŒæœ‰
- æ²¡æœ‰ä½¿ç”¨è€…è‡ªåŠ¨æ¸…ç†ã€‚

Stringå’ŒVec<T>

ä½¿ç”¨ç»“æ„ä½“å®ç°ï¼Œ

Deraf

Drop

### Box<T>

å®ç°äº†

Deraf

Drop

å…è®¸åœ¨heapä¸Šå­˜å‚¨æ•°æ®

åœ¨Stackæœ‰ä¸€ç‚¹å†…å­˜ï¼ŒæŒ‡å‘heap

å¯ä½¿ç”¨ä¸é€’å½’

æ— é™å¤§å°

```rust
use crate::List::{Cons,Nil};
enum List {
    Cons(i32,List),
    Nil,
}
fn box_test(){
    let b = Box::new(5);
    println!("{}",b);
    let list = Cons(1,Cons(2,Cons(3,Nil)));
}
```

Boxè§£å†³

```rust
use crate::List::{Cons,Nil};
enum List {
    Cons(i32,Box<List>),
    Nil,
}
fn box_test(){
    let b = Box::new(5);
    println!("{}",b);
    let list = Cons(1,Box::new(Cons(2,
        Box::new(Cons(3,Box::new(Nil))))));
}
```

### Deraf

```rust
fn test_drefe(){
    let x = 4;
    let y = Box::new(x);
    assert_eq!(4,x);
    assert_eq!(4,*y);
}
```

```rust
use std::ops::Deref;
struct MyBox<T>(T);
impl <T> MyBox<T> {
    fn new(x:T)->MyBox<T>{
        MyBox(x)
    }
}
impl<T> Deref for MyBox<T>  {
    type Target = T;
    fn deref(&self)->&T{
        &self.0
    }
}
fn test_drefe(){
    let x = 4;
    let y = Box::new(x);
    let y = MyBox::new(x);
    assert_eq!(4,x);
    assert_eq!(4,*y);
}
```



### Drop

ç½‘ç»œï¼Œæ–‡ä»¶èµ„æºé‡Šæ”¾

ä¸èƒ½æ‰‹åŠ¨è°ƒç”¨

```rust
struct CustomSmartPointer{
    data:String,
}
impl Drop for CustomSmartPointer {
    fn drop(&mut self){
        println!("Droping data: {}",self.data);
    }
}
fn test_drop(){
    let c = CustomSmartPointer{
        data:String::from("hello"),
    };
    println!("CustomSmartPointer constructed");
}
```

å¯ä»¥ç”¨æ ‡å‡†åº“çš„dropï¼Œæ¥ä¸¢å¼ƒã€‚

```rust
 drop(c);
```

### Rc<T>

å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆ

- å¤šé‡æ‰€æœ‰æƒ
- å•çº¿ç¨‹
- ä¸åœ¨é¢„å¯¼å…¥
- Rc::cloneåªæ‹·è´å¼•ç”¨ï¼Œä¸å…‹éš†æ•°æ®
- ä¸å¯å˜å¼•ç”¨

```rust
use std::rc::Rc;
enum List {
    Cons(i32,Rc<List>),
    Nil,
}
fn test_rc(){
    let a  = Rc::new(Cons(5,
        Rc::new(Cons(10,
            Rc::new(Nil)))));
    println!("count after creating {}",Rc::strong_count(&a));
    {
        let b = Cons(3,Rc::clone(&a));
        println!("count after creating {}",Rc::strong_count(&a));
    }
    let c = Cons(4,Rc::clone(&a));
    println!("count after creating {}",Rc::strong_count(&a));
}
```

### RefCell

- å”¯ä¸€æ‰€æœ‰æƒã€‚
- å¯å˜ã€ä¸å¯å˜å€Ÿç”¨ï¼Œåœ¨è¿è¡Œæ—¶æ£€æŸ¥ã€‚



#### weaké˜²æ­¢å†…å­˜æ³„æ¼

 



## å¹¶å‘

Concurrent:ç¨‹åºçš„ä¸åŒéƒ¨åˆ†ä¹‹é—´ç‹¬ç«‹çš„è¿è¡Œ

Parallel:ç¨‹åºçš„ä¸åŒéƒ¨åˆ†åŒæ—¶è¿è¡Œ

Rustæ— ç•å¹¶å‘

### å¤šçº¿ç¨‹

é—®é¢˜

- ç«äº‰çŠ¶æ€
- æ­»é”

ä½¿ç”¨OSï¼Œ1ï¼š1æ¨¡å‹ï¼Œè¿è¡Œæ—¶å°

è¯­è¨€è‡ªå·±çš„çº¿ç¨‹ï¼ŒM:Næ¨¡å‹ï¼Œè¿è¡Œæ—¶å¤§

Rustæƒè¡¡è¿è¡Œæ—¶çš„æ”¯æŒï¼Œæ ‡å‡†åº“åªæä¾›äº†1ï¼š1æ¨¡å‹ã€‚

ä½¿ç”¨spawnåˆ›å»ºçº¿ç¨‹

ä¸»çº¿ç¨‹ç»“æŸï¼Œå¦ä¸€ä¸ªçº¿ç¨‹ä¹Ÿç»“æŸã€‚æä¾›joinhandleç­‰å¾…çº¿ç¨‹ç»“æŸæ‰ç»“æŸã€‚

```rust
use std::thread;
use std::time::Duration;
fn main() {
    println!("Hello, world!");
    let handle = thread::spawn(||{
        for i in 1..10{
            println!("h1, number {} from the spawned thread!",i);
            thread::sleep(Duration::from_millis(1))
        }
    });
    // handle.join().unwrap();
    for i in 1..5{
        println!("h1, number {} from the main thread",i);
        thread::sleep(Duration::from_millis(1))
    }
    handle.join().unwrap();

}

```

#### moveé—­åŒ…

å¯ä»¥ä½¿ç”¨å…¶ä»–çº¿ç¨‹çš„æ•°æ®ã€‚

```rust
fn spawn_move(){
    let v = vec![1,2,4];
    let handle = thread::spawn(move||{
        println!("here's a vector {:?}",v);
    });
    handle.join().unwrap();
}
```

### æ¶ˆæ¯ä¼ é€’

Channel

åŒ…å«ï¼šå‘é€ç«¯ï¼Œæ¥å—ç«¯

#### åˆ›å»º

mpsc(å¤šç”Ÿäº§è€…ï¼Œå•æ¶ˆè´¹è€…)

mpsc::channel

```rust
use std::sync::mpsc;
use std::thread;
fn create_channel(){
    let (tx,rx) = mpsc::channel();
    thread::spawn(move ||{
        let val = "hi".to_string();
        tx.send(val).unwrap();
    });
    let received = rx.recv().unwrap();//block
    print!("Got {}",received);
}
```

try_recvéé˜»å¡ã€‚

### æ‰€æœ‰æƒ

- sendåæ‰€æœ‰æƒå°±ç§»åŠ¨äº†ã€‚

### å…‹éš†åˆ›å»ºå¤šä¸ªå‘é€è€…

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn clone_sender(){
    let (tx,rx) = mpsc::channel();
    let tx1  = mpsc::Sender::clone(&tx);

    thread::spawn(move ||{
        let vals = vec![
            String::from("1: hi"),
            String::from("1: from"),
            String::from("1: the"),
            String::from("1: thread"),
        ];
        for val in vals{
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });
    thread::spawn(move ||{
        let vals = vec![
            String::from("2: hi"),
            String::from("2: from"),
            String::from("2: the"),
            String::from("2: thread"),
        ];
        for val in vals{
            tx.send(val).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });
    for received in rx{
        println!("Got: {}",received);
    }
}
```

### å…±äº«å†…å­˜å¹¶å‘

channelæ˜¯å•æ‰€æœ‰æƒï¼Œå…±äº«æ˜¯å¤šæ‰€æœ‰æƒ

Mutexåªå…è®¸ä¸€ä¸ªçº¿ç¨‹æ¥è®¿é—®æŸäº›æ•°æ®ã€‚

é€šè¿‡lockï¼Œå’Œunlockæ¥ä½¿ç”¨

```
use std::sync::Mutex;
fn create_mutex(){
    let m = Mutex::new(5);
    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }//unlock
    println!("m = {:?}",m);

}
```

#### å¤šçº¿ç¨‹å¤šæ‰€æœ‰æƒ

Rcè¦å®ç°send

Arcï¼ŒåŸå­Rc

```rust
use std::sync::{Mutex,Arc};
use std::rc::Rc;
fn create_mutex(){
    let m = Mutex::new(5);
    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }//unlock
    println!("m = {:?}",m);

}
fn mutex_thread(){
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    for _ in 0..10{
        let counter = Arc::clone(&counter);
        let handle = std::thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    for handle in handles{
        handle.join().unwrap();
    }
    println!("Result {}",*counter.lock().unwrap());

}
```



### Send Sync trait

send è½¬ç§»æ‰€æœ‰æƒã€‚

å‡ ä¹æ‰€æœ‰ç±»å‹éƒ½å®ç°äº†send

Syncå…è®¸å¤šä¸ªçº¿ç¨‹è®¿é—®

Rcï¼Œæœªå®ç°ï¼ŒMutexå®ç°äº†ã€‚



## é¢å‘å¯¹è±¡

å°è£…ã€ç»§æ‰¿ã€å¤šæ€

Rustï¼Œå°è£…ï¼›æ²¡æœ‰ç»§æ‰¿ï¼Œtraitå¯ä»¥å¤ç”¨ï¼›å¤šæ€ï¼Œæ³›å‹å’Œtraitçº¦æŸï¼›

### å®ç°é¢å‘å¯¹è±¡çš„è®¾è®¡æ¨¡å¼

### çŠ¶æ€æ¨¡å¼

```rust
pub struct Post{
    state:Option<Box<dyn State>>,
    content:String,
}
impl Post {
    pub fn new()->Post{
        Post{
            state:Some(Box::new(Draft {})),
            content:String::new(),
        }
    }
    pub fn add_text(&mut self,text:&str){
        self.content.push_str(text)
    }
    pub fn content(&self) ->&str{
        self.state.as_ref().unwrap().content(&self)
    }
    pub fn request_review(&mut self){
        if let Some(s) = self.state.take(){
            self.state = Some(s.request_review())
        }
    }
    pub fn approve(&mut self){
        if let Some(s) = self.state.take(){
            self.state = Some(s.approve())
        }
    }

}


trait State {
    fn request_review(self:Box<Self>) ->Box<dyn State>;
    fn approve(self:Box<Self>) ->Box<dyn State>;
    fn content<'a>(&self,post:&'a Post) -> &'a str{
        ""
    }
}
struct Draft {}
impl State for Draft {
    fn request_review(self: Box<Self>) ->Box<dyn State>{
        Box::new(PendingReview {})
    }
    fn approve(self: Box<Self>)->Box<dyn State>{
        self
    }
}

struct PendingReview {}
impl State for PendingReview {
    fn request_review(self: Box<Self>) ->Box<dyn State>{
        self
    }
    fn approve(self: Box<Self>)->Box<dyn State>{
        Box::new(Published{})
    }
}
struct Published {}
 
impl State for Published {
    fn request_review(self: Box<Self>) ->Box<dyn State>{
        self
    }
    fn approve(self: Box<Self>)->Box<dyn State>{
        self
    }
    fn content<'a>(&self,post:&'a Post) -> &'a str{
        &post.content
    }
}
```

```rust
use Blog::Post;

fn main() {
    println!("Hello, world!");
    let mut post  = Post::new();
    post.add_text("I ate a salad for lunch today");

    post.request_review();
    
    post.approve();

}

```

## æ¨¡å¼

æ¨¡å¼åŒ¹é…

æœ‰ï¼Œå­—é¢å€¼ï¼Œæ•°å€¼ã€ç»“æ„ä½“ã€æšä¸¾ã€å˜é‡ã€é€šé…ç¬¦ã€å ä½ç¬¦

ä½¿ç”¨æ¨¡å¼

- match
- if let
- while let
- for
- let
- å‡½æ•°å‚æ•°

### å¯è¾©é©³å‹

æ— å¯è¾©é©³çš„ï¼Œlet x = 5;

å¯è¾©é©³çš„ ï¼Œ if let some(v) = a_value;



```
- å¿½ç•¥
_x ä¸ä¼šè­¦å‘Š
_ ä¸ä¼šç»‘å®š
{x,..}
(x,..,y)
```

match + if

```
match v{
	4|5|6|7|8 if ..
}
```



## é«˜çº§ç‰¹æ•ˆ

### ä¸å®‰å…¨Rust

ä¸ä¿è¯å†…å­˜å®‰å…¨

- è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆ
- è°ƒç”¨unsafeå‡½æ•°æˆ–æ–¹æ³•
- è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡
- å®ç°unsafe trait

unsafeä»ä¼šæ£€æŸ¥å€Ÿç”¨

#### è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆ

ä¸cäº¤æ¢

```
*mut T
*const T,è¿™é‡Œæ˜¯ç±»å‹åçš„ä¸€éƒ¨åˆ†

```

```rust
fn test(){
    let mut num = 5;
    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
    unsafe{
        println!("r1:{}",*r1);
        println!("r2:{}",*r2);
    }
    let address = 0x012345usize;
    let r = address as *const i32;
    unsafe{
        println!("r:{}",*r);
    }
}
```



### é«˜çº§Trait

```
pub trait Iterator {
    type Item;
    fn next(&mut self) ->Option<Self::Item>;
}
```

ä½¿ç”¨ä¸åŒçš„å‚æ•°å¯ä»¥ä¸ºä¸€ä¸ªstructå¤šæ¬¡å®ç°

é‡è½½

```rust
#[derive(Debug)]
struct Point{
    x:i32,
    y:i32,
}
use std::ops::Add;
impl Add for Point {
    type Output = Point;
    fn add(self,other:Point)->Point{
        Point{
            x:self.x + other.x,
            y:self.y + other.y,
        }
    }
}
fn test_ops(){
    let p1 = Point{
        x:1,
        y:2
    };
    let p2 = Point{
        x:2,
        y:3,
    };
    println!("{:?}",p1+p2);
}
```

å®Œå…¨é™å®šè¯­æ³•

```
<Type as Trait>::function(receiver_if_method,next_arg,..);
```

ç±»å‹åˆ«å

```
type elem = i32;//æ­¤åelemè¡¨ç¤ºi32ç±»å‹
```

å‡½æ•°æŒ‡é’ˆ

```
Fn,FnMut,FnOnce
```



## å®

å®æ˜¯å…ƒç¼–ç¨‹ã€‚

å£°æ˜å®ï¼Œå¿«å¼ƒç”¨äº†

è¿‡ç¨‹å®ï¼Œ

- è‡ªå®šä¹‰æ´¾ç”Ÿ
- å±æ€§å®
- å‡½æ•°å®



## ç»“è¯¾é¡¹ç›®

å•çº¿ç¨‹

```rust

use std::net::{TcpListener,TcpStream};
use std::io::{Read,Write};
use std::fs;
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    for stream in listener.incoming(){
        let stream = stream.unwrap();
        println!("Connection established!");
        handle_connection(stream);
    }
}
fn handle_connection(mut stream:TcpStream){
    let mut buffer = [0;512];
    stream.read(&mut  buffer).unwrap();
    // println!("Request: {}",String::from_utf8_lossy(&buffer[..]));
    let get = b"GET / HTTP/1.1\r\n";
    let (status_line,filename) = if buffer.starts_with(get){
        ("HTTP/1.1 200 OK\r\n\r\n","hello.html")
    }else {
        ("HTTP/1.1 404 NOT FOUND\r\n\r\n","404.html")
    };
    let response = format!("{}{}",status_line,fs::read_to_string(filename).unwrap());
    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}

```

å®Œæ•´

```rust
use std::net::{TcpListener,TcpStream};
use std::io::{Read,Write};
use std::fs;
use std::io::prelude::*;
use std::thread;
use std::time::Duration;
use server::ThreadPool;
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);
    for stream in listener.incoming().take(2){
        let stream = stream.unwrap();
        pool.excute(||{
            handle_connection(stream);
        });
    }
}
fn handle_connection(mut stream:TcpStream){
    let mut buffer = [0;512];
    stream.read(&mut  buffer).unwrap();
    // println!("Request: {}",String::from_utf8_lossy(&buffer[..]));
    let get = b"GET / HTTP/1.1\r\n";
    let (status_line,filename) = if buffer.starts_with(get){
        ("HTTP/1.1 200 OK\r\n\r\n","hello.html")
    }else {
        ("HTTP/1.1 404 NOT FOUND\r\n\r\n","404.html")
    };
    let response = format!("{}{}",status_line,fs::read_to_string(filename).unwrap());
    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}

```

```rust
use std::thread;
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

enum Message {
    NewJob(Job),
    Terminate,
}

pub struct ThreadPool{
    workers:Vec<Worker>,    
    sender:mpsc::Sender<Message>,
}

impl ThreadPool {
    pub fn new(size:usize)->ThreadPool{
        assert!(size>0);
        let (sender,receiver) = mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));
        let mut workers = Vec::with_capacity(size);
        for id in 0..size{
            workers.push(Worker::new(id,Arc::clone(&receiver)));
        }
        ThreadPool {workers,sender}
    }
    pub fn excute<F>(&self,f:F)
    where 
        F:FnOnce() + Send +'static,
    {
        let job = Box::new(f);
        self.sender.send(Message::NewJob(job)).unwrap();
    }
}
impl Drop for ThreadPool {
    fn drop(&mut self){
        println!("Sending terminate message to all workers.");

        for _ in &mut self.workers{
            self.sender.send(Message::Terminate).unwrap();
        }
        println!("Shutting down all workers.");
        
        for worker in &mut self.workers{
            println!("Shutting down worker {}",worker.id);
            if let Some(thread) = worker.thread.take(){
                thread.join().unwrap();
            }
            
        } 
    }
}

// struct Job;
type Job = Box<dyn FnBox + Send + 'static>;

struct  Worker{
    id:usize,
    thread:Option<thread::JoinHandle<()>>,
}
trait FnBox {
    fn call_box(self:Box<Self>);
}
impl <F: FnOnce()>FnBox for F {
    fn call_box(self: Box<Self>){
        (*self)();
    }
}

impl Worker {
    fn new(id:usize,receiver:Arc<Mutex<mpsc::Receiver<Message>>>) ->Worker{
        let thread =  thread::spawn(move || loop{
            let message  = receiver.lock().unwrap().recv().unwrap();
            match message{
                Message::NewJob(job) =>{
                    println!("Worker {} got a job;executing",id);
                    job.call_box();

                }
                Message::Terminate =>{
                    println!("Worker {} was told to terminate",id);
                    break;
                }
            };  
        });
        Worker{id,thread:Some(thread)}
    }
}
```

## æ„å»ºè„šæœ¬

æœ‰cåº“,é“¾æ¥cåº“ç­‰,ç”Ÿæˆrustæ¨¡å—

1. æ·»åŠ ä¾èµ–

   ```
   [package]
   name = "script_learning"
   version = "0.1.0"
   edition = "2021"
   build = "build.rs"
   # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
   
   [dependencies]
   
   ```

2. ç¼–å†™build.rs

   ```rust
   use std::env;
   use std::fs::File;
   use std::io::Write;
   use std::path::Path;
   
   fn main(){
       let out_dir = env::var("OUT_DIR").unwrap();
       let dest_path = Path::new(&out_dir).join("hello.rs");
       let mut f = File::create(&dest_path).unwrap();
   
       f.write_all(b"
           pub fn say_hello() -> &'static str{
               \"hello\"
           }
       ").unwrap();
   }
   ```

3. è°ƒç”¨

   ```rust
   
   include!{concat!(env!("OUT_DIR"),"/hello.rs")}
   
   fn main() {
       println!("{}",say_hello());
   }
   
   ```

å¤–éƒ¨

1. ä¾èµ–

   ```
   [build-dependencies]
   cc = '1.0'
   
   ```

2. build.rs

   ```rust
   extern crate cc;
   fn main(){
       cc::Build::new().file("src/hello.c").compile("hello");
   }
   ```

3. hello.c

   ```c
   #include<stdio.h>
   void hello(){
       printf("hello world 11\n");
   }
   ```

4. main.rs

   ```rust
   
   // include!{concat!(env!("OUT_DIR"),"/hello.rs")}
   extern {fn hello();}
   
   fn main() {
       // println!("{}",say_hello());
       unsafe{
           hello();
       }
   }
   
   ```

   

