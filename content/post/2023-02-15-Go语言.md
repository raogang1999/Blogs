---
title: "Go语言"
author: "Gang R"   
description : "Go语言"     
date: 2023-02-15T20:14:18+08:00
draft: false
tags:    
  - Go              
  - 编程语言

categories:    
  - 编程语言 
keywords:    
  - Go
---
参考书籍《Go程序设计语言》
学习Go语言基础，并记录相关知识和代码。


# 第一章 入门

## 1.1 Hello world

创建helloworld.go

```go
package main

import "fmt"

func main() {
	fmt.Println("hello,世界")
}

```

```
运行
go run helloworld.go
编译
go build helloworld.go
```



## 1.2 命令行参数

输出命令行参数

```go
func v1() {
	var s, sep string
    for i := 1; i < len(os.Args); i++ {//i:=1,表示定义i=1，并自动根据初值确定类型，此后为正常变量。
		s += sep + os.Args[i]
		sep = " "
	}
	fmt.Println(s)
}
```

```
go run .\2_args.go pwd hello run
```

使用range简化

```go
func v2() {
	var s, sep string
	for _, arg := range os.Args[1:] {// range 返回 key value
		s += sep + arg
		sep = " "
	}
	fmt.Println(s)
}
```

```
go run .\2_args.go pwd hello run
```

使用Join简化

```go
func v3() {
	res := strings.Join(os.Args[1:], " ")
	print(res)
}
```

## 1.3 重复行

```go
import (
	"bufio"
	"fmt"
	"os"
)

func dup1() {
	counts := make(map[string]int) //make函数用来创建新的map
	input := bufio.NewScanner(os.Stdin)
	for input.Scan() {
		counts[input.Text()]++
	}
	for line, n := range counts {
		if n >= 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}

func main() {
	dup1()
}
```

```
go run .\3_duplicate_line.go
hello 
bob
said
by
alice
bob
is
a
good
man
alice
word
world
hello

```

版本二，文件与命令行

```go
func dup2() {
	counts := make(map[string]int) //make函数用来创建新的map
	files := os.Args[1:]
	if len(files) == 0 {
		countLines(os.Stdin, counts)
	} else {
		for _, arg := range files {
			f, err := os.Open(arg)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Dup2:%v\n", err)
				continue
			}
			countLines(f, counts)
			f.Close()
		}
		for line, n := range counts {
			if n >= 1 {
				fmt.Printf("%d\t%s\n", n, line)
			}
		}

	}
}
func countLines(f *os.File, counts map[string]int) {
	input := bufio.NewScanner(f)
	for input.Scan() {
		counts[input.Text()]++
	}

}
```



```
 go run .\3_duplicate_line.go hello.txt
```

## 1.4 GIF

```go
package main

import (
	"image"
	"image/color"
	"image/gif"
	"io"
	"log"
	"math"
	"math/rand"
	"net/http"
	"os"
	"time"
)

var palette = []color.Color{color.White, color.Black}

const (
	whiteIndex = 0
	blackIndex = 1
)

func main() {
	rand.Seed(time.Now().UTC().UnixNano())
	if len(os.Args) > 1 && os.Args[1] == "web" {
		handler := func(w http.ResponseWriter, r *http.Request) {
			lissajous(w)
		}
		http.HandleFunc("/", handler)
		log.Fatal(http.ListenAndServe("localhost:8080", nil))
		return
	}
	lissajous(os.Stdout)
}

func lissajous(out io.Writer) {
	const (
		cycles  = 5     // 完整的x振荡器变化的个数
		res     = 0.001 // 角度分辨率
		size    = 100   // 图像画布包含[-size...size]
		nframes = 60    //动画中的帧数
		delay   = 10    // 以10ms为单位的帧间延迟
	)
	freq := rand.Float64() * 3.0
	anim := gif.GIF{LoopCount: nframes}
	phase := 0.0
	for i := 0; i < nframes; i++ {
		rect := image.Rect(0, 0, 2*size+1, 2*size+1)
		img := image.NewPaletted(rect, palette)
		for t := 0.0; t < cycles*2*math.Pi; t += res {
			x := math.Sin(t)
			y := math.Sin(t*freq + phase)
			img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex)
		}
		phase += 0.1
		anim.Delay = append(anim.Delay, delay)
		anim.Image = append(anim.Image, img)
	}
	gif.EncodeAll(out, &anim)

}

```

```
go run gif.go web
```



## 1.5 获取一个url

go 可以方便的创建服务器，并且有并发性。

```go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
)

func main() {
	for _, url := range os.Args[1:] {
		resp, err := http.Get(url)

		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch:%v\n", err)
			os.Exit(1)
		}
		b, err := ioutil.ReadAll(resp.Body)

		resp.Body.Close()
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
			os.Exit(1)
		}
		fmt.Printf("%s", b)
	}
}
```

```
go fetch.go http://www.baidu.com
```

```go
if _, err := io.Copy(os.Stdout, resp.Body); err != nil {
			log.Fatal(err)
		}
```

## 1.6 并发获取多个URL

Go并发获取多个URL

```go
package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"time"
)

func main() {
	start := time.Now()
	ch := make(chan string)
	for _, url := range os.Args[1:] {
		go fetch(url, ch) //启动一个goroutine
	}
	for range os.Args[1:] {
		fmt.Println(<-ch)
	}
	fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
}

func fetch(url string, ch chan<- string) {
	start := time.Now()
	resp, err := http.Get(url)

	if err != nil {
		ch <- fmt.Sprint(err)
		return
	}
	nbytes, err := io.Copy(ioutil.Discard, resp.Body)
	resp.Body.Close()
	if err != nil {
		ch <- fmt.Sprintf("while reading %s: %v", url, err)
		return
	}
	secs := time.Since(start).Seconds()
	ch <- fmt.Sprintf("%2fs %7d %s", secs, nbytes, url)

}

```



## 1.7 一个web服务器

简单服务器

```go
package main

import (
	"fmt"
	"log"
	"net/http"
)

func main() {
	http.HandleFunc("/", handler1)
	log.Fatal(http.ListenAndServe("localhost:8080", nil))
}

func handler1(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)

}

```



带有并发锁的计数服务器

```go
package main

import (
	"fmt"
	"log"
	"net/http"
	"sync"
)

var mu sync.Mutex
var count int

func main() {
	http.HandleFunc("/", handler)
	http.HandleFunc("/count", counter)
	log.Fatal(http.ListenAndServe("localhost:8080", nil))
}

func handler(w http.ResponseWriter, r *http.Request) {
	mu.Lock()
	count++
	mu.Unlock()
	fmt.Fprintf(w, "URL.Path=%q\n", r.URL.Path)
}

func counter(w http.ResponseWriter, r *http.Request) {
	mu.Lock()
	fmt.Fprintf(w, "Count %d\n", count)
	mu.Unlock()
}

```

显示相关协议与表单

```go
package main

import (
	"fmt"
	"log"
	"net/http"
)

func main() {

	http.HandleFunc("/", handler2)
	log.Fatal(http.ListenAndServe("localhost:8080", nil))

}
func handler2(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "%s %s %s", r.Method, r.URL, r.Proto)
	for k, v := range r.Header {
		fmt.Fprintf(w, "Hander[%q]=%q\n", k, v)
	}
	fmt.Fprintf(w, "Host = %q\n", r.Host)
	fmt.Fprintf(w, "RemoteAddr = %q\n", r.RemoteAddr)

	if err := r.ParseForm(); err != nil {
		log.Print(err)
	}
	for k, v := range r.Form {
		fmt.Fprintf(w, "Form[%q]=%q\n", k, v)
	}
}

```

## 1.8 others

switch

```go
package main

import (
	"fmt"
	"math/rand"
)

func coinflip() string {
	if rand.Int()%2 == 1 {
		return "heads"
	} else {
		return "tails"
	}
}
func test1() {
	heads, tails := 0, 0
	for i := 0; i < 5; i++ {
		switch coinflip() {
		case "heads":
			heads++
		case "tails":
			tails++
		default:
			fmt.Println("landed on edge!")
		}
	}

	fmt.Printf("in 5 times,\nheads: %d\ntails:%d", heads, tails)
}

func Signum(x int) int {
	switch { //相当于switch true
	case x > 0:
		return +1
	default:
		return 0
	case x < 0:
		return -1

	}
}
func test2() {
	println(Signum(-1))
}

func main() {
	test2()
}

```



# 第二章 程序结构

## 2.1 名称

开头是字母或下划线，后面是数字字母下划线，区分大小写

实体声明在函数外，则对包内可见，同一个package。实体第一个字母大写则对包外可用。

驼峰式命名

## 2.2 声明

四种实体声明（包级别）：

- 变量： var
- 常量：const
- 类型：type
- 函数：func

package 包声明

import 声明

## 2.3 变量

```go
var name type = expression
```

type与expression可以省略一个，不能都省略。

type省略，类型与第一次赋值有关。

expression省略，对应零值。nil,0,false,””。

### 2.3.1 短变量声明

```go
name := expression
```

短变量可以只声明部分变量

```go
in, err := os.Open(infile)
out, err := os.Create(outfile)//这里err不是声明，只是赋值
```

短变量声明至少有一个新变量。

### 2.3.2 指针

变量的名，操作的直接是变量的值

指针的值是变量的地址。所有变量都有地址。

```go
package main

import "fmt"

func main() {
	x := 1
	p := &x
	fmt.Println(*p)//1
	*p = 2
	println(x)//2

}

```

指针相等的情况，都为nil,或者，指向同一个地址

```go
func f() *int {
	v := 1
	return &v
}

func pointerTest2() {
	var p = f()
	fmt.Println(*p)         //1
	fmt.Println(f() == f()) //false
}
```

返回局部变量地址是安全的，

每次调用函数返回的地址都不一样

---

作为函数变量

```go
func incr(p *int) int {
	*p++
	return *p
}
func pointerTest3() {
	v := 1
	incr(&v)
	fmt.Println(incr(&v))
}
```

---

解析命令行参数

```go
var n = flag.Bool("n", false, "omit trailing newline")
var sep = flag.String("s", " ", "separator")

func pointerTest4() {
	flag.Parse()
	fmt.Print(strings.Join(flag.Args(), *sep))
	if !*n {
		fmt.Println()
	}
}
```

```shell
go run echo.go -help
go run echo.go -s - a b c
go run echo.go -n a b d
```

### 2.3.3 new函数

创建对应类型的空指针

```go
import "fmt"

func main() {
	p := new(int)
	fmt.Println(*p) //0
	*p = 2
	fmt.Println(*p) //2
}
```

### 2.3.4 变量的生命周期

包级别变量的生命周期是整个程序的执行时间。

局部变量：==动态生命周期== 每次执行声明语句时，创建一个新的实体，变量一直生存到它变得不可访问。

```go
package main

var global *int

func h() {
	var x int
	x = 1
	global = &x//x逃逸了
}
func i() {
	y := new(int)
	*y = 1//y没有再被使用，y分配在栈上
}
func main() {
	h()
}
```

## 2.4 赋值

=

支持

```
++
--
*=
+=
..
```

### 2.4.1 多重赋值

```go
x,y = y,x
a[i],a[j] = a[j],a[i]

func gcd(x,y int) int{
    for y != 0{
        x,y = y,x%y
    }
    return x
}

v,ok = m[key] //map查询
v,ok = x.(T) //类型断言
v,ok = <-ch  //通道接收

```

隐式赋值

- 传参
- 返回值
- 复合类型声明

## 2.5 类型声明

```go
type name underlyin-type
```

起别名

```go
type Celsius float64

type Fahrenheit float64

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC     Celsius = 0
	BoilingC      Celsius = 100
)

func CToF(c Celsius) Fahrenheit {
	return Fahrenheit(c*9/5 + 32)
}
func FtoC(f Fahrenheit) Celsius {
	return Celsius((f - 32) * 5 / 9)
}
```

 

## 2.6 包和文件

一个包的源代码可以在多个.go文件中，

```
package name
```



### 2.6.1 导入

```
import 
```

###  2.6.2 包初始化

包级别变量，顺序初始化，遇到依赖，先解析依赖。

```

var a = b+c //最后把a初始化为3
var b = f() // 通过调用f把b初始化为2
var c = 1 // 首先初始化为1
```



## 2.7 作用域

语法块

```
for {}
if {}
switch {}
select {}
{}
```

语法块决定了作用域。

内层覆盖外层



# 第三章 基本数据

四大类：

- 基础类型：数字、字符串（string）、布尔类型（boolean）
- 聚合类型：数组（array）、结构体（struct）
- 引用类型：指针（pointer）、slice、map、function、channel
- 接口类型



## 3.1 整型

```go
var a int8 = 1
var b int16 = 2
var c int32 = 3
var d int64 = 4
var e int = 5 //原生
println(a,b,c,d,e)
rune 类型等于 int32 类型
byte 类型等于 uint8 类型
uintptr 大小不明，但可以放完整指针
int 与 int32 类型不同，需要转换
```

运算符优先级

```go
* / % << >> & &^
+ - | ^ == != < <= > >= 
&& 
||
```

位运算

```
&
|
^
&^
<<
>>
```

## 3.2 浮点数

```go
float32 3.4e38
float64 1.7e308
```

```go
package main

import (
	"fmt"
	"math"
	"os"
)

const (
	width, height = 600, 320
	cells         = 100
	xyrange       = 30.0
	xyscale       = width / 2 / xyrange
	zscale        = height * 0.4
	angle         = math.Pi / 6
)

var sin30, cos30 = math.Sin(angle), math.Cos(angle)

func main() {
	res := ""
	res += fmt.Sprintf("<svg xmlns='http://www.w3.org/2000/svg'"+
		"style='stroke:grey;fill:white;stroke-width:0.7'"+
		"width='%d' height='%d'>", width, height)
	for i := 0; i < cells; i++ {
		for j := 0; j < cells; j++ {
			ax, ay := corner(i+1, j)
			bx, by := corner(i, j)
			cx, cy := corner(i, j+1)
			dx, dy := corner(i+1, j+1)
			res += fmt.Sprintf("<polygon points='%g,%g %g,%g %g,%g %g,%g'/>\n",
				ax, ay, bx, by, cx, cy, dx, dy)
		}
	}
	res += "</svg>"
	file, err := os.Create("sin.svg")
	if err != nil {
		panic(err)
	}
	defer file.Close()
	_, err = file.WriteString(res)
	if err != nil {
		panic(err)
	}
}

func corner(i, j int) (float64, float64) {
	x := xyrange * (float64(i)/cells - 0.5)
	y := xyrange * (float64(j)/cells - 0.5)

	z := f(x, y)
	sx := width/2 + (x-y)*cos30*xyscale
	sy := height/2 + (x+y)*xyscale - z*zscale
	return sx, sy
}
func f(x, y float64) float64 {
	r := math.Hypot(x, y)
	return math.Sin(r)
}

```

## 3.3 复数

```go
x := 1+2i
cmplx包
cmplx.Sqrt(-1)
```

```go
package main

import (
	"image"
	"image/color"
	"image/png"
	"math/cmplx"
	"os"
)

func main() {
	const (
		xmin, ymin, xmax, ymax = -2, -2, +2, +2
		width, height          = 1024, 1024
	)
	img := image.NewRGBA(image.Rect(0, 0, width, height))
	for py := 0; py < height; py++ {
		y := float64(py)/height*(ymax-ymin) + ymin
		for px := 0; px < width; px++ {
			x := float64(px)/width*(xmax-xmin) + xmin
			z := complex(x, y)
			img.Set(px, py, mandelbrot(z))
		}
	}
	file, err := os.Create("a1.png")
	if err != nil {
		panic(err)
	}
	defer file.Close()
	if err := png.Encode(file, img); err != nil {
		panic(err)
	}
}
func mandelbrot(z complex128) color.Color {
	const iterations = 200
	const contrast = 15
	var v complex128
	for n := uint8(0); n < iterations; n++ {
		v = v*v + z
		if cmplx.Abs(v) > 2 {
			return color.Gray{255 - contrast*n}
		}
	}
	return color.Black

}

```

![image-20230217222301853](http://imgs.iprivacy.top/MyNoteBook/ComputerLanguguages/Go/image-20230217222301853.png)



## 3.4 布尔值

bool只有ture和false两种可能。

&& 优先级高于||

## 3.5 字符串

字符串是==不可变的==的字节序列。

len(s)返回的是字节数。

可以切片

```go
s[0:5] //[0,5)
```

+号可以产生新的字符串，可以做比较按字节比较。

```go
func main() {
	s := "left foot"
	t := s
	s += ",right foot" //并不改变原来字符串的值，只是将新的字符串赋值给了s。
	println(t)
	println(s)
	s[0] = 'a' //编译报错
}
```

不可变意味着底层可共用内存。

### 3.5.1 字符串字面量

字符串都可写作，string literal

```
"hello,世界"
```

Go按照UTF-8编码用双引号，原生字符串字面量用

```
`content`
```

### 3.5.2 Unicode

Go语言为Unicode编码数字取名为rune

四个字节天然适合int32,

```go
int32 = rune
```

### 3.5.3 UTF-8

UTF-8以字节为单位对Unicode码作变长编码。

```go
func test2() {
	s := "Hello,世界"
	fmt.Println(len(s))
	fmt.Println(utf8.RuneCountInString(s))
	for i := 0; i < len(s); {
		r, size := utf8.DecodeRuneInString(s[i:])
		fmt.Printf("%d\t%c\n", i, r)
		i += size
	}
	//在range内解码
	for i, r := range s {
		fmt.Printf("%d\t%q\t%d\n", i, r, r)
	}
	//统计字符数
	n := 0
	for range s {
		n++
	}
	fmt.Printf("%d\n", n)
}
```

如果遇到不合理的字符会解码为

```
\uFFFD
```

用rune数组可以很方便的访问每个utf8编码

```go
func test3() {
	s := "こんにちは世界"
	fmt.Printf("%x\n", s)
	r := []rune(s)
	fmt.Printf("%x\n", r)
	fmt.Println(string(r))
	fmt.Println(string('\ufffd'))
	fmt.Println(string(65))
}
```

### 3.5.4 字符串和字节slice

四个包：

- bytes
- strings
- strconv
- unicode

模仿basenaem

```go
func basename(s string) string {
	//去掉最后一个/之前的所有内容
	for i := len(s) - 1; i >= 0; i-- {
		if s[i] == '/' {
			s = s[i+1:]
			break
		}
	}
	//保留最后一个.之前的所有内容
	for i := len(s) - 1; i >= 0; i-- {
		if s[i] == '.' {
			s = s[:i]
			break
		}
	}
	return s
}

func test4() {
	fmt.Println(basename("a/b/c.go"))
	fmt.Println(basename("c.d.go"))
	fmt.Println(basename("abc"))
}
```



“12312312”->“12,312,312”

```go
func comma(s string) string {
	n := len(s)
	if n <= 3 {
		return s
	}
	return comma(s[:n-3]) + "," + comma(s[n-3:])
}

```

字节slice可以随意修改，字符串不行，但是可以相互转换

```go
func test5() {
	s := "abc"
	b := []byte(s)
	s2 := string(b)
	println(s2)
}
```

在go语言中，strings和bytes都提供了六个函数

```
func Contains(s,substr string)bool
```

他们唯一的不同是，bytes的操作对象是字节slice，而strings是存在字符串。

为了高效处理字节slice，bytes提供了Buffer类型，无需初始化。

```go
func intsToString(values []int) string {

	var buf bytes.Buffer
	buf.WriteByte('[')
	for i, v := range values {
		if i > 0 {
			buf.WriteString(", ")
		}
		fmt.Fprintf(&buf, "%d", v)
	}
	buf.WriteByte(']')
	return buf.String()

}
func test6() {
	println(intsToString([]int{1, 2, 3, 4}))
}
```



### 3.5.5 字符串和数字的相互转换

strconv包

```go
func test7() {
	x := 123
	y := fmt.Sprintf("%d", x)
	fmt.Println(y, strconv.Itoa(x))
	println("-----------")
	fmt.Println(strconv.FormatInt(int64(x), 2))
	println("-----------")
	s := fmt.Sprintf("x=%b", x)
	println(s)
	println("-----------")
	x, err := strconv.Atoi("123")
	if err != nil {
		panic(err)
	}
	println(x)
	if y, err := strconv.ParseInt("2123", 10, 64); err != nil {
		println(y)
	} //最长64位

}
```

## 3.6 常量

所有常量本质上是基本类型：布尔、字符串、数字

```go
const pi = 3.14159
const (
	e = 1
    b = 2
)
```

常量生成器iota

枚举

```go
type Weekday int
const(
	Sunday Weekday= iota//从0开始加
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)
const (
	Sunday Weekday = 1<<iota
    ...
)
```

go的无类型常量

```
ZiB YiB
math.Pi

```

# 第四章 符合数据类型

## 4.1 数组

```go
package main

import (
	"crypto/sha256"
	"fmt"
)

func test1() {
	var a [3]int
	fmt.Println(a[0])
	fmt.Println(a[len(a)-1])
	for i, v := range a {
		fmt.Printf("%d %d\n", i, v)
	}
	var q [3]int = [3]int{1, 2, 3}
	for _, v := range q {
		fmt.Printf("%d \t", v)
	}
	println()
	r := [...]int{2, 3, 4, 5}
	for _, v := range r {
		fmt.Printf("%d \t", v)
	}

}

func test2() {
	type Currency int
	const (
		USD Currency = iota
		EUR
		GBP
		RMB
	)
	symbol := [...]string{USD: "$", EUR: "€", GBP: "￡", RMB: "￥"}
	fmt.Println(RMB, symbol[RMB])
}
func test3() {
	r := [...]int{99: -1} //100个数，最后一个为-1
	for _, v := range r {
		fmt.Printf("%d ", v)
	}
	a := [2]int{1, 2}
	b := [...]int{1, 2}
	c := [2]int{1, 3}
	fmt.Println(a == b, a == c, b == c) //ture false false
	//d:=[3]int{1,2,}
	//fmt.Println(a==d)//编译错误，长度不同
}
func test4() {
	c1 := sha256.Sum256([]byte("x"))
	c2 := sha256.Sum256([]byte("x"))
	fmt.Printf("%x\n%x\n%t\n,%T\n", c1, c2, c1 == c2, c1)
	//2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
	//2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
	//true
	//,[32]uint8

}
func test5() {
	a := [...]int{31: 0}
	one(&a)
	for _, v := range a {
		fmt.Printf("%d ", v)
	}
	fmt.Println(len(a))
}
func main() {
	test5()
}

```

统计hash结果不同的个数

```go
func PopCount(a [32]uint8, b [32]uint8) int {
	count := 0
	for i := range a {
		if a[i] != b[i] {
			count++
		}
	}
	return count
}
```

## 4.2 slice

slice是轻量级数据结构，底层是数组。

slice的三个属性：指针、长度、容量

定义

```go
[]T
```

slice的操作符

```
s[i:j](0<=i<=j<=cap(s))
```

```go
func sliceTest1() {
	month := []string{1: "January", 2: "February", 3: "March", 4: "April", 5: "May",
		6: "June", 7: "July", 8: "August", 9: "September", 10: "October", 11: "November", 12: "December"}
	fmt.Println(month[4:7])
	summer := month[6:9]
	//fmt.Println(summer[:10])    //报错，索引不能超过
	endlessSummer := summer[:7] //赋值可以扩容6-》12
	fmt.Println(endlessSummer)
	nop := summer[:8] //报错,超出原切片大小
	fmt.Println(nop)
}
```

字符串与字节slice操作相识，结果上一个返回字符串，一个返回slice。

反转

```go
func reverse(s []int) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}
func main() {
	s := []int{0, 1, 2, 3, 4, 5}
	reverse(s[:2])
	reverse(s[2:])
	reverse(s)
	fmt.Println(s)
}

```

slice 只能直接与nil比较是否相等。

```go
func equal(x, y []string) bool {
	if len(x) != len(y) {
		return false
	}
	for i := range x {
		if x[i] != y[i] {
			return false
		}
	}
	return true
}
```

内置函数make

```
make([]T,len)
make([]T,len,cap)
```

make创建无名数组，并返回他的一个slice。

### 4.2.1 append函数

```go
func sliceTest3() {
	var runes []rune
	for _, r := range "Hello, 世界" {
		runes = append(runes, r)
	}
	fmt.Printf("%q\n", runes)
}
```

关于int的append

```go
func appendInt(x []int, y int) []int {
	var z []int
	zlen := len(x) + 1
	if zlen <= cap(x) {
		z = x[:zlen]
	} else {
		zcap := zlen
		if zcap < 2*len(x) {
			zcap = 2 * len(x)

		}
		z = make([]int, zlen, zcap)
		copy(z, x)
	}
	z[len(x)] = y
	return z
}
func sliceTest4() {
	var x, y []int
	for i := 0; i < 10; i++ {
		y = appendInt(x, i)
		fmt.Printf("%d cap=%d\t%v\n", i, cap(y), y)
		x = y
	}
}
func main() {
	sliceTest4()
}

```

### 4.2.2 slice 就地修改



```go
func nonempty(strings []string) []string {
	i := 0
	for _, s := range strings {
		if s != "" {
			strings[i] = s
			i++
		}
	}
	return strings[:i]

}
func sliceTest5() {
	data := []string{"one", "", "three"}
	data = nonempty(data)
	fmt.Printf("%q\n", data)
}

```

## 4.3 map

散列表，他是一个拥有键值对元素的无序集合。

在Go中，map是散列表的引用，map的类型是map[k]v,所有的键都有用相同的类型，所有的值都拥有相同的类型。

```go
func mapTest1() {
	//ages := make(map[string]int)//方法一
	ages := map[string]int{ //方法二
		"alice":   31,
		"charlie": 34,
	}
	for k, v := range ages { //遍历的顺序是随机的
		fmt.Printf("%q->%d\n", k, v)
	}
	fmt.Println(ages["bob"])
	delete(ages, "alice")
	delete(ages, "bob")
	ages["bob"]++
	//&ages["bob"]//不可以获取地址
}

func main() {
	mapTest1()
}

```

map的零值是nil，且零值的map不能赋值

```go
func mapTest2() {
	var ages map[string]int
	fmt.Println(ages == nil)    //true
	fmt.Println(len(ages) == 0) //true
	//ages["bob"] = 21//报错
	//必须先初始化
	ages = make(map[string]int)
	age, ok := ages["bob"]
	if !ok {
		fmt.Println("bob is not in the map")
	}
	fmt.Println(age)
	
}
```

map与slice一样，都无法通过==来判断是否相同。

```go
func mapEqual(x, y map[string]int) bool {
	if len(x) != len(y) {
		return false
	}
	for k, xv := range x {
		if yv, ok := y[k]; !ok || yv != xv {//因为存在零值
			return false
		}
	}
	return true
}

```

Go没有集合数据类型，可以用map模拟

```go
func dedup() {
	seen := make(map[string]bool)
	input := bufio.NewScanner(os.Stdin)
	for input.Scan() {
		line := input.Text()
		if !seen[line] {
			seen[line] = true
			fmt.Println(line)
		}
	}
	if err := input.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "dedup:%v\n", err)
		os.Exit(1)
	}
}
```

直接将slice作为键是不可行的，因为slice无法比较，

```go
var m = make(map[string]int)

func help(list []string) string {
	return fmt.Sprintf("%q", list)
}
func Add(list []string) {
	m[help(list)]++
}
func Count(list []string) int {
	return m[help(list)]
}
func mapTest3() {
	list := []string{
		"hello", "world", "hi", "bob", "hello",
	}
	Add(list)
	fmt.Println(Count(list))
}

func main() {
	mapTest3()

}
```

map的类型本身可以是复合类型

```go
var graph = make(map[string]map[string]bool)

func addEdge(from, to string) {
	edges := graph[from]
	if edges == nil {
		edges = make(map[string]bool)
		graph[from] = edges
	}
	edges[to] = true
}
func hasEdge(from, to string) bool {
	return graph[from][to]
}
func mapTest4() {
	addEdge("a", "b")
	addEdge("a", "c")
	println(hasEdge("a", "c"))
}
func main() {
	mapTest4()

}

```

## 4.4 结构体

将多个任意类型变量组合成一个。

```go
package main

import (
	"fmt"
	"time"
)

type Employee struct {
	ID        int
	Name      string
	Address   string
	Dob       time.Time
	Position  string
	Salary    int
	ManagerID int
	Say       func()
} //所有成员都是变量

func structTest1() {
	var dilbert Employee
	dilbert.ID = 1                    //所以可以直接访问
	position := &dilbert.Position     //可以获取地址
	*position = "Senior " + *position //指针访问
	employeeOfTheMonth := &dilbert
	employeeOfTheMonth.Position += " {proactive team player}" //可以直接用.访问等同于（*xxx).Position += ""
	fmt.Println(dilbert)
	fmt.Println(EmployeeByID(dilbert.ID).Position) //可以直接访问
	id := dilbert.ID
	EmployeeByID(id).Salary = 0 //直接访问
}
func EmployeeByID(id int) *Employee {
	//do...
	return nil
}


func main() {
	structTest1()
}

```

结构体中大写的变量可导出，小写的不行。

同一个结构体内不允许有与结构体同名，但可以有指针

```go
type tree struct {
	value       int
	left, right *tree
}

func Sort(values []int) {
	var root *tree
	for _, v := range values {
		root = add(root, v)
	}
	appendValues(values[:0], root)
}

//中序遍历
func appendValues(values []int, t *tree) []int {
	if t != nil {
		values = appendValues(values, t.left)
		values = append(values, t.value)
		values = appendValues(values, t.right)
	}
	return values
}

//构造排序树
func add(t *tree, value int) *tree {
	if t == nil {
		t = new(tree)
		t.value = value
		return t
	}
	if value < t.value {
		t.left = add(t.left, value)

	} else {
		t.right = add(t.right, value)
	}
	return t
}

func main() {
	data := []int{2, 3, 1, 6, 7, 9, 4, 0, 5}
	Sort(data)
	fmt.Println(data)

}
```

### 4.4.1 结构体字面量

结构体类型的值可以通过结构体字面量来设置，

```go
func structTest3() {
	a := Point{2, 3} //按顺序赋值，不太推荐，除非清晰明白
	fmt.Println(a)
	b := gif.GIF{LoopCount: 2} //指定赋值
	fmt.Println(b)
}
```

![image-20230224213341946](http://imgs.iprivacy.top/MyNoteBook/ComputerLanguguages/Go/image-20230224213341946.png)

可以作为参数和返回值

```go
func Scale(p Point, factor int) Point {
	return Point{p.x * factor, p.y * factor}
}
```

但通常都是传指针

```go
func Bonus(e *Employee, percent int) int {
	return e.Salary * percent / 100
}
```

### 4.4.2 结构体的比较

如果结构体的成员变量是可比较的，则可比较。否则不行。可比较则可作为map的key

```go
	test := make(map[Point]int)
	fmt.Println(test)
```



### 4.4.3 结构体嵌套和匿名成员

Go有不同寻常的结构体嵌套机制

定义了圆和车轮

```go
func testStruct4() {
	type Circle struct {
		X, Y, Radius int
	}
	type Wheel struct {
		X, Y, Radius, Spokes int
	}
	var w Wheel
	w.X = 9
	w.Y = 9
	w.Radius = 5
	w.Spokes = 20
}
```

重复太高了于是

```go
func testStruct5() {
	type Point struct {
		X, Y int
	}
	type Circle struct {
		Center Point
		Radius int
	}
	type Wheel struct {
		Circle Circle
		Spokes int
	}
	var w Wheel
	w.Circle.Center.X=9
	w.Circle.Center.Y=9
	w.Circle.Radius = 5
	w.Spokes = 20
}
```

上面让程序变得清晰了，但是访问其成员太复杂了。

Go运行我们不带名称访问成员

```go
func testStruct6() {
	type Point struct {
		X, Y int
	}
	type Circle struct {
		Point
		Radius int
	}
	type Wheel struct {
		Circle
		Spokes int
	}
	var w Wheel
	w.X = 9
	w.Y = 9
	w.Radius = 5
	w.Spokes = 20
	//w = Wheel{8, 8, 5, 20}                       //编译错误
	//w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} //编译错误
}
```

以下两种等价

```go
w = Wheel{Circle{Point{8, 8}, 5}, 20}
w = Wheel{
    Circle: Circle{
        Point:  Point{X: 8, Y: 8},
        Radius: 5,
    },
    Spokes: 20,
}
fmt.Printf("%#v\n", w)
```

## 4.5 JSON

标准库支持，

GO to JSON 

```go
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

type Movie struct {
	Title string
	Year  int  `json:"released"`
	Color bool `json:"color,omitempty"`
	Actor []string
}

var movies = []Movie{
	{Title: "Casablanca", Year: 1942, Color: false,
		Actor: []string{"Humphrey Bogart", "Ingrid Bergman"}},
	{Title: "Cool Hand Luke", Year: 1967, Color: true,
		Actor: []string{"Paul Newman"}},
	{Title: "Bullitt", Year: 1968, Color: true,
		Actor: []string{"Steve McQueen", "Jacqueline Bisset"}},
}

func testJson1() {
	data, err := json.Marshal(movies)
	if err != nil {
		log.Fatal("JSON marshaling failed:%s", err)
	}
	fmt.Printf("%s\n", data)
	//[{"Title":"Casablanca","released":1942,"Actor":["Humphrey Bogart","Ingrid Bergman"]},{"Title":"Cool Hand Luke","released":1967,"color":true,"Actor":["Paul Newman"]},{"Title":"Bullitt","released":1968,"color":true,"Actor":["Steve McQueen","Jacqueline Bisset"]}]
	data, err = json.MarshalIndent(movies, "", " ")
	if err != nil {
		log.Fatal("JSON marshaling failed:%s", err)
	}
	fmt.Printf("%s", data)

}
```

MarshalIndent()，可以带缩进显示。

Go通过反射，可以导出成员为JSON字段，取别名

```go
Year int `json:"released"`
Color bool `json:"color,omitempty"`//为空就不转到json中去
```

解码

```go
var titles []struct{ Title string }
if err := json.Unmarshal(data, &titles); err != nil {
    log.Fatal("JSON unmarshaling failed: %s", err)
}
fmt.Println(titles)//[{Casablanca} {Cool Hand Luke} {Bullitt}]
```

用Go解析一个请求

```go
const IssuesURL = "https://api.github.com/search/issues"

type IssuesSearchResult struct {
	TotalCount int `json:"total_count"`
	Items      []*Issue
}
type Issue struct {
	Number    int
	HTMLURL   string `json:"html_url"`
	Title     string
	State     string
	User      *User
	CreatedAt time.Time `json:"created_at"`
	Body      string
}
type User struct {
	Login   string
	HTMLURL string `json:"html_url"`
}

func SearchIssues(terms []string) (*IssuesSearchResult, error) {
	q := url.QueryEscape(strings.Join(terms, " "))
	resp, err := http.Get(IssuesURL + "?q=" + q)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, fmt.Errorf("search query faild:%s", resp.Status)
	}

	var result IssuesSearchResult
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil { //流式解码Decode
		resp.Body.Close()
		return nil, err
	}
	resp.Body.Close()
	return &result, nil
}

func main() {
	//testJson1()
	result, err := SearchIssues(os.Args[1:])
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("%d issues:\n", result.TotalCount)
	for _, item := range result.Items {
		fmt.Printf("#%-5d %9.9s %.55s\n", item.Number, item.User.Login, item.Title)

	}
}
```

调用

```
go run .\5_json.go repo:golang/go is:open json decoder
```



## 4.6 文本和HTML模板

模板是一个字符串或文件-{{…}}被称为操作。

```go
package main

import (
	"fmt"
	"golearn/git"
	"log"
	"os"
	"text/template"
	"time"
)

const templ = `{{.TotalCount}} issues:
{{range.Items}}--------------------------
Number: {{.Number}}
User: {{.User.Login}}
Title: {{.Title | printf "%.64s"}}
Age:   {{.CreatedAt | daysAgo}} days
{{end}}` // |的输出当下一个函数的输入，print 与fmt.Sprintf同义
func daysAgo(t time.Time) int {
	return int(time.Since(t).Hours() / 24)
}
func new1() {
	report, err := template.New("report").
		Funcs(template.FuncMap{"daysAgo": daysAgo}).Parse(templ)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Println(report)
}

//template.Must解决解析错误问题
var report = template.Must(template.New("issuelist").
	Funcs(template.FuncMap{"daysAgo": daysAgo}).Parse(templ))

func main() {
	result, err := git.SearchIssues(os.Args[1:])
	if err != nil {
		log.Fatal(err)
	}
	if err := report.Execute(os.Stdout, result); err != nil {
		log.Fatal(err)
	}
}
```

# 第五章 函数

本章的案例是爬虫。

##  5.1 函数声明

```go
func name(parameter-list)(result-list){//没有返回值（）可以省略
	body
}
```

形参声明类型指定。

```go
func f(i,j,k int,s,t string){}
```

返回值

```go
func add(x int,y int)(z int){
	z = x+y
	return 
}
```

## 5.2 递归

使用了golang.org/x/net/html

```

```

## 5.3 多返回值

```go
func findLinks(url string) ([]string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, fmt.Errorf("getting %s:%s", url, resp.Status)
	}
	return nil, nil
}
```

## 5.4 错误

一般的

```go
value,ok := cache.Lookup(key)
if !ok{
	// ...cache[key] ...
}
```

### 5.4.1 错误处理策略

- 错误传播

    ```go
    resp,err := http.Get(url)
    if err != nil{
    	return nil,err
    }
    ```

- 短时重复，超过次数再报错

    ```go
    func WaitForServer(url string) error {
    	const timeout = 1 * time.Minute
    	deadline := time.Now().Add(timeout)
    	for tries := 0; time.Now().Before(deadline); tries++ {
    		_, err := http.Head(url)
    		if err != nil {
    			return nil
    		}
    		log.Printf("Server not responding (%s); retrying...", err)
    		time.Sleep(time.Second << uint(tries)) //指数退避策略
    	}
    	return fmt.Errorf("Server %s failed to respond after %s", url, timeout)
    }
    
    
    ```

- 错误可输出，然后停止

    ```go
    func testErr1() {
    	if err := WaitForServer("WWW.rao2gang1.top"); err != nil {
    		//fmt.Println(err)
    		//os.Exit(1)
    		log.Fatalf("Site is down:%v\n", err)//等价
    	} else {
    		fmt.Println("OK")
    	}
    }
    ```

    ```go
    log.SetPrefix("wait: ")
    log.SetFlags(0)
    ```

    

- 只记录错误，继续运行

    ```go
    if err := Ping(); err != nil {
        log.Printf("ping failed %v", err)
    }
    
    ```

### 5.4.2 文件结束标识

```go
var EOF = errors.New("EOF")

in := bufio.NewReader(os.Stdin)

for {
r, _, err := in.ReadRune()
if err == io.EOF {
break
}
if err != nil {
return fmt.Errorf("read failed:%v", err)
}
// 使用
fmt.Println(r)
}
```

## 5.5 函数变量

函数是一种变量

```go
package main

import "fmt"

func square(n int) int {
	return n * n
}
func negative(n int) int {
	return -n
}
func product(m, n int) int {
	return m * n
}
func testFun1() {
	f := square
	fmt.Println(f(3))
	fmt.Println(f)
	f = negative
	fmt.Println(f(3))
	fmt.Printf("%T\n", f)
	//f = product //f 类型已定，不能将func(int,int)int 赋值给func(int)int
	var f1 func(int) int
	//f1(3)//调用空函数，宕机
	if f1 != nil {
		println(f1(3))
	}
}
func main() {
	testFun1()
}

```

函数本身不可比，所以不能当map的key

函数本身可以作为参数传递

```go
func add1(r rune) rune { return r + 1 }
func funcTest2() {
	fmt.Println(strings.Map(add1, "HAL-9000"))
	fmt.Println(strings.Map(add1, "VMS"))
	fmt.Println(strings.Map(add1, "Adminx"))
}
```

```go
func plusTwo(n int) int {
	return n + 2
}
func handler(n int, f func(int) int) {
	fmt.Println(f(n))
}
func testFun3() {
	handler(2, plusTwo)
}
```

## 5.6 匿名函数

```go
func testAno1() {
	fmt.Println(strings.Map(func(r rune) rune {
		return r + 1
	}, "hello"))
}
```

闭包

```go
func squares() func() int {
	var x int
	return func() int {
		x++
		return x * x
	}
}
func testAno2() {
	f := squares()
	fmt.Println(f()) //1
	fmt.Println(f()) //4
	fmt.Println(f()) //9
}
func main() {
	testAno2()
}
```

拓扑排序例子

```go
var prereqs = map[string][]string{
	"algorithms": {"data structures"},
	"calculus":   {"linear algebra"},
	"compilers": {
		"data structures",
		"formal languages",
		"computer organization",
	},
	"data structures":       {"discrete math"},
	"databases":             {"data structures"},
	"discrete math":         {"intro to programming"},
	"formal languages":      {"discrete math"},
	"networks":              {"operating systems"},
	"operating systems":     {"data structures", "computer organization"},
	"programming languages": {"data structures", "computer organization"},
}

//拓扑排序
func topoSort(m map[string][]string) []string {
	var order []string                //记录顺序的表
	seen := make(map[string]bool)     //记录遍历过的元素
	var visitAll func(items []string) //定义函数
	visitAll = func(items []string) { //递归函数
		for _, item := range items { //遍历所有的keys
			if !seen[item] { //如果已经遍历过则返回
				seen[item] = true
				visitAll(m[item])           //递归
				order = append(order, item) //将该项加入到顺序表里
			}
		}
	}
	var keys []string //记录所有的key
	for key := range m {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	visitAll(keys) //调用匿名函数
	return order
}

func testAno3() {
	for i, course := range topoSort(prereqs) {
		fmt.Printf("%d:\t%s\n", i+1, course)
	}
}

func main() {
	testAno3()
}
```

## 5.7 变长函数

```go

func sum(vals ...int) int {
	total := 0
	for _, val := range vals {
		total += val
	}
	return total
}
func testLong1() {
	fmt.Println(sum())
	fmt.Println(sum(3))
	fmt.Println(sum(1, 2, 3, 4))
}
func main() {
	testLong1()
}

```

## 5.8 延迟调用



defer会延时调用，会在调用它的函数返回前调用该函数

```go
func main() {
	defer fmt.Println("world")
	fmt.Printf("hello ")
}

```

```go
hello world
```

对于多个defer 栈式调用

```go
func main() {
defer fmt.Println("first")
defer fmt.Println("second")
defer fmt.Println("third")
}
```

```
third
second
first
```

## 5.9 宕机

## 5.10 恢复



# 第六章 方法

封装、组合

## 6.1 方法声明

函数和方法的区别，

方法可以绑定到其他类型上，如切片。

```go
package main

import (
	"fmt"
	"math"
)

type Point struct {
	X, Y float64
}
type Path []Point

func (path Path) Distance() float64 {
	sum := 0.0
	for i := range path {
		if i > 0 {
			sum += path[i-1].Distance(path[i])
		}
	}
	return sum
}

func Distance(p, q Point) float64 {
	return math.Hypot(q.X-p.X, q.Y-p.Y)
}
func (p Point) Distance(q Point) float64 {
	return math.Hypot(q.X-p.X, q.Y-p.Y)
}
func main() {
	p := Point{3, 4}
	q := Point{6, 8}
	fmt.Println(Distance(q, p))
	fmt.Println(q.Distance(p))
	perim := Path{
		{1, 1},
		{5, 1},
		{5, 4},
		{1, 1},
	}
	fmt.Println(perim.Distance())//12

}
```



## 6.2 指针接收者

定义指针接收，必须用指针形式的变量调用该方法。

指针接收者会改变原来的值，而普通接收者不会。真正接收者才是真正意义上的this/self指针

```go
package main

import "fmt"

type Point struct {
	X, Y float64
}

func (p *Point) ScaleBy(factor float64) {
	p.X *= factor
	p.Y *= factor
}

func PointerReceiverTest1() {
	r := &Point{1, 2}
	r.ScaleBy(2)
	fmt.Println(*r)
	p := Point{1, 2}
	pptr := &p
	pptr.ScaleBy(2)
	fmt.Println(*pptr)
	q := Point{1, 2}
	(&q).ScaleBy(2)
	fmt.Println(q)
}
func main() {
	PointerReceiverTest1()
}
```

对于指针变量，可以隐式的转化为非指针变量调用非指针接收者方法。



```go
type Point struct {
	X, Y float64
}

func (p *Point) ScaleBy(factor float64) {
	p.X *= factor
	p.Y *= factor
}
func (p Point) Distance(q Point) float64 {
	return math.Hypot(q.X-p.X, q.Y-p.Y)
}
func PointerReceiverTest2() {
	r := &Point{2, 2.5}
	r.ScaleBy(2)
	s := Point{1, 1}
    fmt.Println(r.Distance(s))//相当于 (*r).Distance(s)
    s.ScaleBy(2)//相当于 (&s).ScaleBy(2)
	fmt.Println(s)
}
```

nil **是一个合法的接受者**

```go
type IntList struct {
	Value int
	Tail  *IntList
}

func (list *IntList) Sum() int {
	if list == nil {
		return 0
	}
	return list.Value + list.Tail.Sum() //递归
}
func PointerReceiverTest3() {
	list := IntList{1, &IntList{2, nil}}
	println(list.Sum())//3
	list2 := new(IntList)
	println(list2.Sum())//0
}
```

## 6.3 通过结构体内嵌组成类型

```go
package main

import (
	"fmt"
	"image/color"
	"math"
)

type Point2 struct {
	X, Y float64
}

func (p Point2) Distance(q Point2) float64 {
	return math.Hypot(q.X-p.X, q.Y-p.Y)
}

type ColoredPoint struct {
	Point2
	Color color.RGBA
}

func (p *Point2) ScaleBy(factor float64) {
	p.X *= factor
	p.Y *= factor
}
func InsideTest1() {
	var cp ColoredPoint
	cp.X = 1
	cp.Y = 2
	fmt.Println(cp.Point2.X)
	fmt.Println(cp.Y)
	red := color.RGBA{255, 0, 0, 255}
	blue := color.RGBA{0, 0, 255, 255}
	var p = ColoredPoint{Point2{1, 2}, red}
	var q = ColoredPoint{Point2{2, 3}, blue}
	fmt.Println(p.Distance(q.Point2)) //这里必须是Point类型
	p.ScaleBy(2)
	fmt.Println(p)

}
func main() {
	InsideTest1()
}
```



## 6.4 方法变量与表达式

方法变量

```go
p:=Point{1,2}
q:=Point{1,2}
distanceFromP := p.Distance
fmt.Println(distanceFromP(q))
```

表达式

```go
p:=Point{1,2}
q:=Point{1,2}
distance := Point.Distance
fmt.Println(distance(p,q))
```

## 6.5 位向量

位向量使用一个无符号整型值的Slice，每位代表集合的一个元素。

$x/64,x\%64,bit[x/64]=x \%64$

```go
package main

import (
	"bytes"
	"fmt"
)

type IntSet struct {
	words []uint64
}

func (s *IntSet) Has(x int) bool {
	word, bit := x/64, uint(x%64)
	return word < len(s.words) && s.words[word]&(1<<bit) != 0
}
func (s *IntSet) Add(x int) {
	word, bit := x/64, uint(x%64)
	for word >= len(s.words) {
		s.words = append(s.words, 0)
	}
	s.words[word] |= 1 << bit
}
func (s *IntSet) UnionWith(t *IntSet) {
	for i, tword := range t.words {
		if i < len(s.words) {
			s.words[i] |= tword
		} else {
			s.words = append(s.words, tword)
		}
	}
}
func (s *IntSet) String() string {
	var buf bytes.Buffer
	buf.WriteByte('{')
	for i, word := range s.words {
		if word == 0 {
			continue
		}
		for j := 0; j < 64; j++ {
			if word&(1<<uint(j)) != 0 {
				if buf.Len() > len("{") {
					buf.WriteByte(' ')
				}
				fmt.Fprintf(&buf, "%d", 64*i+j)
			}

		}
	}
	buf.WriteByte('}')
	return buf.String()
}
func BitVictorTest() {
	var x, y IntSet
	x.Add(1)
	x.Add(144)
	x.Add(90)
	fmt.Println(x.String())
	y.Add(9)
	y.Add(1)
	fmt.Println(y.String())
	x.UnionWith(&y)
	fmt.Println(x.String())
	fmt.Println(x.Has(9))
}
func main() {
	BitVictorTest()
}
package main

import (
	"bytes"
	"fmt"
)

type IntSet struct {
	words []uint64
}

func (s *IntSet) Has(x int) bool {
	word, bit := x/64, uint(x%64)
	return word < len(s.words) && s.words[word]&(1<<bit) != 0
}
func (s *IntSet) Add(x int) {
	word, bit := x/64, uint(x%64)
	for word >= len(s.words) {
		s.words = append(s.words, 0)
	}
	s.words[word] |= 1 << bit
}
func (s *IntSet) UnionWith(t *IntSet) {
	for i, tword := range t.words {
		if i < len(s.words) {
			s.words[i] |= tword
		} else {
			s.words = append(s.words, tword)
		}
	}
}
func (s *IntSet) String() string {
	var buf bytes.Buffer
	buf.WriteByte('{')
	for i, word := range s.words {
		if word == 0 {
			continue
		}
		for j := 0; j < 64; j++ {
			if word&(1<<uint(j)) != 0 {
				if buf.Len() > len("{") {
					buf.WriteByte(' ')
				}
				fmt.Fprintf(&buf, "%d", 64*i+j)
			}

		}
	}
	buf.WriteByte('}')
	return buf.String()
}
func BitVictorTest() {
	var x, y IntSet
	x.Add(1)
	x.Add(144)
	x.Add(90)
	fmt.Println(x.String())
	y.Add(9)
	y.Add(1)
	fmt.Println(y.String())
	x.UnionWith(&y)
	fmt.Println(x.String())
	fmt.Println(x.Has(9))
}
func main() {
	BitVictorTest()
}

```

## 6.6 封装

大小写控制





# 第七章

其他类型行为的抽象，不用绑定到特定类型上。

Go接口是隐式实现的。



## 7.1 接口即约定

接口是抽象类型，不用知道他是什么，只用知道他可以做什么。

为ByteCounter定义方法，可以使用Fprintf向里面输入值。

```go
package main

import "fmt"

type ByteCounter int

func (c *ByteCounter) Write(p []byte) (int, error) {
	*c += ByteCounter(len(p))
	return len(p), nil
}

func testByteCounter() {
	var c ByteCounter
	c.Write([]byte("hello"))
	fmt.Println(c)
	c = 0
	var name = "Tom"
	fmt.Fprintf(&c, "hello, %s", name)

	fmt.Println(c)
}

func main() {
	testByteCounter()
}

```

定义一个接口

```go
type Stringer interface {
	String() string
}
```

## 7.2 接口类型

声明，注意，实现一个接口，必须实现所有方法。

```go
package main

import "io"

type Reader interface {
	Read(p []byte) (n int, err error)
}
type Closer interface {
	Close() error
}
type ReadWriter interface {
	Reader
	io.Writer
}

type ReadWriterCloser interface {
	Reader
	io.Writer
	Closer
}
```

## 7.3 实现接口



接口赋值规则：当一个表达式实现了一个接口时，这个表达式才可以赋值给接口。

```go
func testInterface() {
	var w io.Writer
	w = os.Stdout
	w = new(bytes.Buffer)
	w = time.Second // 错误，time.Duration 没有Write方法
}
```

空接口： 

```go
var any1 interface{}//可以接受任意类型的值

func main() {
	any1 = true
	any1 = 1.2
	any1 = "hello"
	any1 = map[string]int{"one": 1}
	any1 = new(bytes.Buffer)
	fmt.Println(any1)
	
}
```

```go
type Artifact interface {
	Title() string
	Creators() []string
	Created() time.Time
}
type Text interface {
	Pages() int
	Words() int
	PageSize() int
}
type Audio interface {
	Stream() (io.ReadCloser, error)
	RunningTime() time.Duration
	Format() string
}

```

## 7.4 使用flag.Value解析参数



```go
import (
	"flag"
	"fmt"
	"time"
)

func testResolution() {
	var period = flag.Duration("period", 1*time.Second, "sleep period")
	flag.Parse()
	fmt.Printf("Sleepng for %v...", *period)
	fmt.Println()
}
func main() {
	testResolution()//go run sleep -period 2
}

```


