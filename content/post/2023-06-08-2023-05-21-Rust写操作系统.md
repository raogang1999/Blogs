---
title: "Rust写操作系统"
author: "Gang R"   
description : "为了进一步理解操作系统，减小理论与实践的鸿沟，学习用Rust写操作系统。"     
date: 2023-06-08T11:17:55+08:00
draft: false
tags:    
  - Rust              
  - 操作系统
categories:    
  - 操作系统 
keywords:    
  - 操作系统
  - Rust
  - RISC-V
---



# 环境准备

- 基于http://rcore-os.cn/rCore-Tutorial-Book-v3/index.html

- wsl2 
- ubuntu20.04
- 网络环境

迁移Ubuntu到D盘

```
wsl -l -v
wsl --export Ubuntu-20.04 d://ubuntu-20.04.tar
wsl --unregister Ubuntu-20.04
wsl --import Ubuntu-20.04 d://ubuntu2004 d://ubuntu-20.04.tar
ubuntu2004 config --default-user rao
```

## 设置代理

1. windows防火墙放行代理软件

2. Ubuntu上编写脚本

    ```sh
    #!/bin/sh
    
    # 注意：这个 ip 地址和我们在 windows 中通过 ipconfig 获取的地址等价
    hostip=$(cat /etc/resolv.conf | grep nameserver | awk '{ print $2 }')
    # WSL 自身的 ip
    wslip=$(hostname -I | awk '{print $1}')
    # Windows 上代理软件监听的端口，河对岸为 10808，注意要选中河对岸的 "Allow connections from the LAN"
    port=10808
    
    # 注意代理有两种方式，一种基于 http，一种基于 socket5，河对岸是基于 socket5 的
    PROXY_HTTP="socks5://${hostip}:${port}"
    # PROXY_HTTP="http://${hostip}:${port}" # 如果是基于 http 的代理，则使用该命令
    
    # 开启代理
    set_proxy(){
        export http_proxy="${PROXY_HTTP}"
        export HTTP_PROXY="${PROXY_HTTP}"
        
        export https_proxy="${PROXY_HTTP}"
        export HTTPS_proxy="${PROXY_HTTP}"
        
        export ALL_PROXY="${PROXY_SOCKS5}"
        export all_proxy=${PROXY_SOCKS5}
        
        # 配置 git 的代理
        git config --global http.https://github.com.proxy ${PROXY_HTTP}
        git config --global https.https://github.com.proxy ${PROXY_HTTP}
        
        echo "Proxy has been opened."
    }
    
    # 关闭代理
    unset_proxy(){
        unset http_proxy
        unset HTTP_PROXY
        unset https_proxy
        unset HTTPS_PROXY
        unset ALL_PROXY
        unset all_proxy
        git config --global --unset http.https://github.com.proxy
        git config --global --unset https.https://github.com.proxy
        
        echo "Proxy has been closed."
    }
    
    # 测试代理是否开启成功
    test_setting(){
        echo "Host IP:" ${hostip}
        echo "WSL IP:" ${wslip}
        echo "Try to connect to Google..."
        resp=$(curl -I -s --connect-timeout 5 -m 5 -w "%{http_code}" -o /dev/null www.google.com)
        if [ ${resp} = 200 ]; then
            echo "Proxy setup succeeded!"
        else
            echo "Proxy setup failed!"
        fi
    }
    
    # 根据我们的输入来执行代理的开启、关闭和测试过程
    if [ "$1" = "set" ]
    then
        set_proxy
    elif [ "$1" = "unset" ]
    then
        unset_proxy
    elif [ "$1" = "test" ]
    then
        test_setting
    else
        echo "Unsupported arguments."
    fi
    
    ```

3. 使用

    ```shell
    source /etc/scripts/proxy.sh set：开启代理；
    source /etc/scripts/proxy/sh test：测试代理能否正常工作。如果您的代理可以正常工作，您将会看到消息：Proxy setup succeeded!；否则，您将会看到控制台输出：Proxy setup failed!；
    source /etc/scripts/proxy.sh unset：关闭代理。
    ```

## 安装rust

安装

```
curl https://sh.rustup.rs -sSf | sh
```

使能

```
source $HOME/.cargo/env
```

查看安装情况

```
rustc --version
```

镜像，~/.cargo/config

```
[source.crates-io]
registry = "https://github.com/rust-lang/crates.io-index"
replace-with = 'ustc'
[source.ustc]
registry = "git://mirrors.ustc.edu.cn/crates.io-index"
```

安装依赖

```
rustup target add riscv64gc-unknown-none-elf
cargo install cargo-binutils
rustup component add llvm-tools-preview
rustup component add rust-src
```



## 安装Qemu 模拟器

1. 安装依赖

    ```
    sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \
                  gawk build-essential bison flex texinfo gperf libtool patchutils bc \
                  zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-dev git tmux python3 ninja-build
    ```

2. 下载qemu

    ```
    wget https://download.qemu.org/qemu-7.0.0.tar.xz
    ```

3. 解压安装

    ```
    tar xvJf qemu-7.0.0.tar.xz
    cd qemu-7.0.0
    ./configure --target-list=riscv64-softmmu,riscv64-linux-user
    make -j$(nproc)
    sudo make install
    ```

4. 确认版本

    ```
    qemu-system-riscv64 --version
    qemu-riscv64 --version
    ```

    

##  运行rCore-Tutorial-v3

下载

```
git clone https://github.com/rcore-os/rCore-Tutorial-v3.git
```

编译

```
cd rCore-Tutorial-v3/
cd os/
make
make run
```

# 第一章 应用程序与基本执行环境



## 本章导读



实现一个LibOS，用于提供输出字符串的功能，

实践

```
cd rCore-Tutorial-v3
git checkout ch1
```

在QEMU模拟器上运行，

```
cd os
LOG=TRACE make run
```

输出信息

```rust
[RustSBI output]
[rustsbi] RustSBI version 0.3.1, adapting to RISC-V SBI v1.0.0
.______       __    __      _______.___________.  _______..______   __
|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
|      /     |  |  |  |    \   \       |  |      \   \    |   _  < |  |
|  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |
| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|
[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2
[rustsbi] Platform Name      : riscv-virtio,qemu
[rustsbi] Platform SMP       : 1
[rustsbi] Platform Memory    : 0x80000000..0x88000000
[rustsbi] Boot HART          : 0
[rustsbi] Device Tree Region : 0x87000000..0x87000ef2
[rustsbi] Firmware Address   : 0x80000000
[rustsbi] Supervisor Address : 0x80200000
[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)
[rustsbi] pmp02: 0x80000000..0x80200000 (---)
[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)
[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)
[kernel] Hello, world!
[TRACE] [kernel] .text [0x80200000, 0x80203000)
[DEBUG] [kernel] .rodata [0x80203000, 0x80205000)
[ INFO] [kernel] .data [0x80205000, 0x80206000)
[ WARN] [kernel] boot_stack top=bottom=0x80216000, lower_bound=0x80206000
[ERROR] [kernel] .bss [0x80216000, 0x80217000)
```

![LibOS总体结构](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/lib-os-detail.png)

S-Mode 指的是 Supervisor 模式，是操作系统使用的特权级别，可执行特权指令等。M-Mode是 Machine模式，其特权级别比S-Mode还高，可以访问RISC-V处理器中的所有系统资源。

LibOS源码：

```
./os/src
Rust        4 Files   119 Lines
Assembly    1 Files    11 Lines

├── bootloader(内核依赖的运行在 M 特权级的 SBI 实现，本项目中我们使用 RustSBI)
│   └── rustsbi-qemu.bin(可运行在 qemu 虚拟机上的预编译二进制版本)
├── LICENSE
├── os(我们的内核实现放在 os 目录下)
│   ├── Cargo.toml(内核实现的一些配置文件)
│   ├── Makefile
│   └── src(所有内核的源代码放在 os/src 目录下)
│       ├── console.rs(将打印字符的 SBI 接口进一步封装实现更加强大的格式化输出)
│       ├── entry.asm(设置内核执行环境的的一段汇编代码)
│       ├── lang_items.rs(需要我们提供给 Rust 编译器的一些语义项，目前包含内核 panic 时的处理逻辑)
│       ├── linker-qemu.ld(控制内核内存布局的链接脚本以使内核运行在 qemu 虚拟机上)
│       ├── main.rs(内核主函数)
│       └── sbi.rs(调用底层 SBI 实现提供的 SBI 接口)
├── README.md
└── rust-toolchain(控制整个项目的工具链版本)
```



首先要移除依赖标准库的支持，开发裸机上可以运行的程序，

为了让LibOS内核能够正确对接到 Qemu 模拟器上，需要了解 Qemu 模拟器的启动流程，还需要一些程序内存布局和编译流程（特别是链接）相关知识，这样才能将LibOS内核加载到正确的内存位置上，并使得它能够在 Qemu 上正常运行。为了确认内核被加载到正确的内存位置，我们会在LibOS内核中手写一条汇编指令，并使用 GDB 工具监控 Qemu 的执行流程确认这条指令被正确执行。

我们想用 Rust 语言来实现内核的大多数功能，因此我们需要进一步将控制权从第一条指令转交给 Rust 入口函数。



## 应用程序执行环境与平台支持

从一个最简单的 Rust 应用程序入手，深入地挖掘它下面的多层执行环境，分析编译器和操作系统为应用程序的开发和运行提供了怎样的便利条件。

在linux上，写一个rust hello world

```
cargo new os --bin
tree os
os
├── Cargo.toml
└── src
    └── main.rs
在main.rs中
fn main() {
    println!("Hello, world!");
}
```

运行

```
cargo run
```

我们现在位于最上层

![image-20230527164725603](./assets/image-20230527164725603.png)

实际用到的系统调用，`strace target/debug/os`

```
# 输出字符串
write(1, "Hello, world!\n", 14)         = 14
# 程序退出执行
exit_group(0)
```

从硬件的角度来看，它上面的一切都属于软件。硬件可以分为三种： 处理器 (Processor，也称CPU)，内存 (Memory) 还有 I/O 设备。

CPU 通过，**指令集体系结构** (ISA, 访问



### 目标平台与目标三元组

现代编译器工具集（以C或Rust编译器为例）的主要工作流程如下：

1. 源代码（source code） –> 预处理器（preprocessor） –> 宏展开的源代码
2. 宏展开的源代码 –> 编译器（compiler） –> 汇编程序
3. 汇编程序 –> 汇编器（assembler）–> 目标代码（object code）
4. 目标代码 –> 链接器（linker） –> 可执行文件（executables）

Rust编译器通过 **目标三元组** (Target Triplet) 来描述一个软件运行的目标平台。

```
rustc 1.71.0-nightly (1a5f8bce7 2023-05-26)
binary: rustc
commit-hash: 1a5f8bce74ee432f7cc3aa131bc3d6920e06de10
commit-date: 2023-05-26
host: x86_64-unknown-linux-gnu
release: 1.71.0-nightly
LLVM version: 16.0.4
```

**主线任务**：我们希望能够在另一个硬件平台上运行 `Hello, world!`，而与之前的默认平台不同的地方在于，我们将 CPU 架构从 x86_64 换成 RISC-V。

这里我们选择 `riscv64gc-unknown-none-elf` 目标平台。这其中的 CPU 架构是 riscv64gc ，CPU厂商是 unknown ，操作系统是 none ， elf 表示没有标准的运行时库（表明没有任何系统调用的封装支持），但可以生成 ELF 格式的执行程序。

**RISC-V 指令集拓展**：由于基于 RISC-V 架构的处理器可能用于嵌入式场景或是通用计算场景，因此指令集规范将指令集划分为最基本的 RV32/64I 以及若干标准指令集拓展。每款处理器只需按照其实际应用场景按需实现指令集拓展即可。RV32/64I、M 拓展、A 拓展、F/D 拓展、C 拓展。G 拓展是基本整数指令集 I 再加上标准指令集拓展 MAFD 的总称，因此 riscv64gc 也就等同于 riscv64imafdc。

#### Rust 标准库与核心库

尝试切换平台

```
cargo run --target riscv64gc-unknown-none-elf
can't find crate for `std`
```

 Rust 语言标准库的一个限制是，它需要有操作系统的支持。所以，如果你要实现的软件是运行在裸机上的操作系统，就不能直接用 Rust 语言标准库了。

Rust 有一个对 Rust 语言标准库–std 裁剪过后的 Rust 语言核心库 core。core库是不需要任何操作系统支持的，它的功能也比较受限，但是也包含了 Rust 语言相当一部分的核心机制，可以满足我们的大部分功能需求。

## 移除标准库依赖



移除printfln!宏

```
 rustup target add riscv64gc-unknown-none-elf
```

创建目标与配置文件config

```
# os/.cargo/config
[build]
target = "riscv64gc-unknown-none-elf"
```

交叉编译，是一个与本地编译相对应的概念，即在一种平台上编译出在另一种平台上运行的程序。

这只是使得我们之后在 `cargo build` 的时候不必再加上 `--target` 参数的一个小 trick。

我们在 `main.rs` 的开头加上一行 `#![no_std]` 来告诉 Rust 编译器不使用 Rust 标准库 std 转而使用核心库 core（core库不需要操作系统的支持）。编译器报出如下错误：

```
error: cannot find macro `println` in this scope
```

目前先通过将 `println!` 宏注释掉的简单粗暴方式，来暂时绕过这个问题。

```
error: `#[panic_handler]` function required, but not found
```

`panic!` 宏最典型的应用场景包括断言宏 `assert!` 失败或者对 `Option::None/Result::Err` 进行 `unwrap` 操作。所以Rust编译器在编译程序时，从安全性考虑，需要有 `panic!` 宏的具体实现。

而更底层的核心库 core 中只有一个 `panic!` 宏的空壳，并没有提供 `panic!` 宏的精简实现。因此我们需要自己先实现一个简陋的 panic 处理函数，这样才能让“三叶虫”操作系统 – LibOS的编译通过.

- 我们创建一个新的子模块 `lang_items.rs` 实现panic函数，

- 并通过 `#[panic_handler]` 属性通知编译器用panic函数来对接 `panic!` 宏。

- 为了将该子模块添加到项目中，我们还需要在 `main.rs` 的 `#![no_std]` 的下方加上 `mod lang_items;` ，

```rust
// os/src/lang_items.rs
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

```rust
// os/src/main.rs
#![no_std]
mod lang_items;
// ... other code
```

注意，panic 处理函数的函数签名需要一个 `PanicInfo` 的不可变借用作为输入参数，它在核心库中得以保留，这也是我们第一次与核心库打交道。之后我们会从 `PanicInfo` 解析出错位置并打印出来，然后杀死应用程序。但目前我们什么都不做只是在原地 `loop` 。

### **移除main函数**

此时 cargo build报错

```
error: requires `start` lang_item
```

事实上 `start` 语义项代表了标准库 std 在执行应用程序之前需要进行的一些初始化工作。由于我们禁用了标准库，编译器也就找不到这项功能的实现了。

我们在 `main.rs` 的开头加入设置 `#![no_main]` 告诉编译器我们没有一般意义上的 `main` 函数，并将原来的 `main` 函数删除。在失去了 `main` 函数的情况下，编译器也就不需要完成所谓的初始化工作了。

```rust
// os/src/main.rs
#![no_main]
#![no_std]
mod lang_items;
// ... other code
```

### 分析被移除标准库的程序

安装工具

```
cargo install cargo-binutils
rustup component add llvm-tools-preview
```

```shell
#文件格式
file target/riscv64gc-unknown-none-elf/debug/os
# 文件头信息
rust-readobj -h target/riscv64gc-unknown-none-elf/debug/os
#反汇编导出汇编程序
rust-objdump -S target/riscv64gc-unknown-none-elf/debug/os
```

## 内核第一条指令（基础篇）

### 计算机组成基础

操作系统提供了一些监控工具，可以帮助我们统计 CPU、内存、硬盘、网络等资源的占用情况，从而让我们大致上了解这些资源的使用情况，并帮助我们更好地开发或部署应用程序，在实际编写操作系统的时候，我们就必须直面这些硬件资源，将它们管理起来并为应用程序提供高效易用的抽象。

计算机主要由处理器（Processor，也即中央处理器，CPU，Central Processing Unit），物理内存和 I/O 外设三部分组成。

 x86、RISC-V 等架构采用的是小端序。

对于 RISC-V 处理器而言，load/store 指令进行数据访存时，数据在内存中的地址应该对齐。如果访存 32 位数据，内存地址应当按 32 位（4字节）对齐。如果数据的地址没有对齐，执行访存操作将产生异常。这也是在学习内核编程中经常碰到的一种 bug。

### 了解 Qemu 模拟器



makefile中，可以看到

```shell
qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios ../bootloader/rustsbi-qemu.bin \
    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000
```

- `-machine virt` 表示将模拟的 64 位 RISC-V 计算机设置为名为 `virt` 的虚拟计算机。

- `-nographic` 表示模拟器不需要提供图形界面，而只需要对外输出字符流。

- 通过 `-bios` 可以设置 Qemu 模拟器开机时用来初始化的引导加载程序（bootloader），这里我们使用预编译好的 `rustsbi-qemu.bin` ，它需要被放在与 `os` 同级的 `bootloader` 目录下，该目录可以从每一章的代码分支中获得。

- 通过虚拟设备 `-device` 中的 `loader` 属性可以在 Qemu 模拟器开机之前将一个宿主机上的文件载入到 Qemu 的物理内存的指定位置中， `file` 和 `addr` 属性分别可以设置待载入文件的路径以及将文件载入到的 Qemu 物理内存上的物理地址。注意这里我们载入的文件带有 `.bin` 后缀，它并不是上一节中我们移除标准库依赖后构建得到的内核可执行文件，而是还要进行加工处理得到内核镜像。

**Qemu 启动流程**

在Qemu模拟的 `virt` 硬件平台上，物理内存的起始物理地址为 `0x80000000` ，物理内存的默认大小为 128MiB ，它可以通过 `-m` 选项进行配置。

在本书中，我们只会用到最低的 8MiB 物理内存，对应的物理地址区间为 `[0x80000000,0x80800000)` 。

如果使用上面给出的命令启动 Qemu ，那么在 Qemu 开始执行任何指令之前，首先把两个文件加载到 Qemu 的物理内存中：即作把作为 bootloader 的 `rustsbi-qemu.bin` 加载到物理内存以物理地址 `0x80000000` 开头的区域上，同时把内核镜像 `os.bin` 加载到以物理地址 `0x80200000` 开头的区域上。

Qemu 模拟的启动流程则可以分为三个阶段：第一个阶段由固化在 Qemu 内的一小段汇编程序负责；第二个阶段由 bootloader 负责；第三个阶段则由内核镜像负责。

- 第一阶段：将必要的文件载入到 Qemu 物理内存之后，Qemu CPU 的程序计数器（PC, Program Counter）会被初始化为 `0x1000` ，因此 Qemu 实际执行的第一条指令位于物理地址 `0x1000` ，接下来它将执行寥寥数条指令并跳转到物理地址 `0x80000000` 对应的指令处并进入第二阶段。从后面的调试过程可以看出，该地址 `0x80000000` 被固化在 Qemu 中，作为 Qemu 的使用者，我们在不触及 Qemu 源代码的情况下无法进行更改。
- 第二阶段：由于 Qemu 的第一阶段固定跳转到 `0x80000000` ，我们需要将负责第二阶段的 bootloader `rustsbi-qemu.bin` 放在以物理地址 `0x80000000` 开头的物理内存中，这样就能保证 `0x80000000` 处正好保存 bootloader 的第一条指令。在这一阶段，bootloader 负责对计算机进行一些初始化工作，并跳转到下一阶段软件的入口，在 Qemu 上即可实现将计算机控制权移交给我们的内核镜像 `os.bin` 。这里需要注意的是，对于不同的 bootloader 而言，下一阶段软件的入口不一定相同，而且获取这一信息的方式和时间点也不同：入口地址可能是一个预先约定好的固定的值，也有可能是在 bootloader 运行期间才动态获取到的值。我们选用的 RustSBI 则是将下一阶段的入口地址预先约定为固定的 `0x80200000` ，在 RustSBI 的初始化工作完成之后，它会跳转到该地址并将计算机控制权移交给下一阶段的软件——也即我们的内核镜像。
- 第三阶段：为了正确地和上一阶段的 RustSBI 对接，我们需要保证内核的第一条指令位于物理地址 `0x80200000` 处。为此，我们需要将内核镜像预先加载到 Qemu 物理内存以地址 `0x80200000` 开头的区域上。一旦 CPU 开始执行内核的第一条指令，证明计算机的控制权已经被移交给我们的内核，也就达到了本节的目标。

### 程序内存布局与编译流程

**布局**

在我们将源代码编译为可执行文件之后，它就会变成一个看似充满了杂乱无章的字节的一个文件。但我们知道这些字节至少可以分成代码和数据两部分，在程序运行起来的时候它们的功能并不相同：

- 代码部分由一条条可以被 CPU 解码并执行的指令组成，而数据部分只是被 CPU 视作可读写的内存空间。事实上我们还可以根据其功能进一步把两个部分划分为更小的单位： **段** (Section) 。
- 不同的段会被编译器放置在内存不同的位置上，这构成了程序的 **内存布局** (Memory Layout)。一种典型的程序相对内存布局如下所示：

​	<img src="./assets/image-20230527173402170.png" alt="image-20230527173402170" style="zoom:25%;" />

在上图中可以看到，代码部分只有代码段 `.text` 一个段，存放程序的所有汇编代码。而数据部分则还可以继续细化：

- 已初始化数据段保存程序中那些已初始化的全局数据，分为 `.rodata` 和 `.data` 两部分。前者存放只读的全局数据，通常是一些常数或者是 常量字符串等；而后者存放可修改的全局数据。
- 未初始化数据段 `.bss` 保存程序中那些未初始化的全局数据，通常由程序的加载者代为进行零初始化，即将这块区域逐字节清零；
- **堆** （heap）区域用来存放程序运行时动态分配的数据，如 C/C++ 中的 malloc/new 分配到的数据本体就放在堆区域，它向高地址增长；
- **栈** （stack）区域不仅用作函数调用上下文的保存与恢复，每个函数作用域内的局部变量也被编译器放在它的栈帧内，它向低地址增长。

**局部变量与全局变量**

在一个函数的视角中，它能够访问的变量包括以下几种：

- 函数的输入参数和局部变量：保存在一些寄存器或是该函数的栈帧里面，如果是在栈帧里面的话是基于当前栈指针加上一个偏移量来访问的；
- 全局变量：保存在数据段 `.data` 和 `.bss` 中，某些情况下 gp(x3) 寄存器保存两个数据段中间的一个位置，于是全局变量是基于 gp 加上一个偏移量来访问的。
- 堆上的动态变量：本体被保存在堆上，大小在运行时才能确定。而我们只能 *直接* 访问栈上或者全局数据段中的 **编译期确定大小** 的变量。因此我们需要通过一个运行时分配内存得到的一个指向堆上数据的指针来访问它，指针的位宽确实在编译期就能够确定。该指针即可以作为局部变量放在栈帧里面，也可以作为全局变量放在全局数据段中。

**编译流程**

从源代码得到可执行文件的编译流程可被细化为多个阶段（虽然输入一条命令便可将它们全部完成）：

1. **编译器** (Compiler) 将每个源文件从某门高级编程语言转化为汇编语言，注意此时源文件仍然是一个 ASCII 或其他编码的文本文件；
2. **汇编器** (Assembler) 将上一步的每个源文件中的文本格式的指令转化为机器码，得到一个二进制的 **目标文件** (Object File)；
3. **链接器** (Linker) 将上一步得到的所有目标文件以及一些可能的外部目标文件链接在一起形成一个完整的可执行文件。

汇编器输出的每个目标文件都有一个独立的程序内存布局，它描述了目标文件内各段所在的位置。而链接器所做的事情是将所有输入的目标文件整合成一个整体的内存布局。在此期间链接器主要完成两件事情：

- 第一件事情是将来自不同目标文件的段在目标内存布局中重新排布。如下图所示，在链接过程中，分别来自于目标文件 `1.o` 和 `2.o` 段被按照段的功能进行分类，相同功能的段被排在一起放在拼装后的目标文件 `output.o` 中。注意到，目标文件 `1.o` 和 `2.o` 的内存布局是存在冲突的，同一个地址在不同的内存布局中存放不同的内容。而在合并后的内存布局中，这些冲突被消除。

    ![image-20230527173747798](./assets/image-20230527173747798.png)

- 第二件事情是将符号替换为具体地址。因为符号对应的变量或函数都是放在某个段里面的固定位置（如全局变量往往放在 `.bss` 或者 `.data` 段中，而函数则放在 `.text` 段中），所以我们需要等待符号所在的段确定了它们在内存布局中的位置之后才能知道它们确切的地址。我们需要将这些外部符号记录下来，放在目标文件一个名为符号表（Symbol table）的区域内。

## 内核第一条指令（实践篇）

首先我们编写内核第一条指令并嵌入到我们的内核项目中，接着指定内核的内存布局使得我们的内核可以正确对接到 Qemu 中。

它不支持完整的可执行文件，因此我们从内核可执行文件中剥离多余的元数据得到内核镜像并提供给 Qemu。

我们使用 GDB 来跟踪 Qemu 的整个启动流程并验证内核的第一条指令被正确执行。

### 编写内核第一条指令

```assembly
# os/src/entry.asm
     .section .text.entry
     .globl _start
 _start:
     li x1, 100
```

实际的指令位于第 5 行，也即 `li x1, 100` 。 `li` 是 Load Immediate 的缩写，也即将一个立即数加载到某个寄存器，因此这条指令可以看做将寄存器 `x1` 赋值为 `100` 。

第 4 行我们声明了一个符号 `_start` ，该符号指向紧跟在符号后面的内容——也就是位于第 5 行的指令，因此符号 `_start` 的地址即为第 5 行的指令所在的地址。

第 3 行我们告知编译器 `_start` 是一个全局符号，因此可以被其他目标文件使用。

第 2 行表明我们希望将第 2 行后面的内容全部放到一个名为 `.text.entry` 的段中.

一般情况下，所有的代码都被放到一个名为 `.text` 的代码段中，这里我们将其命名为 `.text.entry` 从而区别于其他 `.text` 的目的在于我们想要确保该段被放置在相比任何其他代码段更低的地址上。这样，作为内核的入口点，这段指令才能被最先执行。

接着，我们在 `main.rs` 中嵌入这段汇编代码，这样 Rust 编译器才能够注意到它，不然编译器会认为它是一个与项目无关的文件：

```rust
// os/src/main.rs
#![no_std]
#![no_main]

mod lang_items;

use core::arch::global_asm;
global_asm!(include_str!("entry.asm"));
```

第 8 行，我们通过 `include_str!` 宏将同目录下的汇编代码 `entry.asm` 转化为字符串并通过 `global_asm!` 宏嵌入到代码中。

### 调整内核的内存布局

由于链接器默认的内存布局并不能符合我们的要求，为了实现与 Qemu 正确对接，我们可以通过 **链接脚本** (Linker Script) 调整链接器的行为，使得最终生成的可执行文件的内存布局符合Qemu的预期，即内核第一条指令的地址应该位于 0x80200000 。

我们修改 Cargo 的配置文件来使用我们自己的链接脚本 `os/src/linker.ld` 而非使用默认的内存布局：

```rust
 // os/.cargo/config
 [build]
 target = "riscv64gc-unknown-none-elf"

 [target.riscv64gc-unknown-none-elf]
 rustflags = [
     "-Clink-arg=-Tsrc/linker.ld", "-Cforce-frame-pointers=yes"
 ]
```

创建链接脚本，`linker.ld`

```assembly
OUTPUT_ARCH(riscv)
ENTRY(_start)
BASE_ADDRESS = 0x80200000;

SECTIONS
{
    . = BASE_ADDRESS;
    skernel = .;

    stext = .;
    .text : {
        *(.text.entry)
        *(.text .text.*)
    }

    . = ALIGN(4K);
    etext = .;
    srodata = .;
    .rodata : {
        *(.rodata .rodata.*)
        *(.srodata .srodata.*)
    }

    . = ALIGN(4K);
    erodata = .;
    sdata = .;
    .data : {
        *(.data .data.*)
        *(.sdata .sdata.*)
    }

    . = ALIGN(4K);
    edata = .;
    .bss : {
        *(.bss.stack)
        sbss = .;
        *(.bss .bss.*)
        *(.sbss .sbss.*)
    }

    . = ALIGN(4K);
    ebss = .;
    ekernel = .;

    /DISCARD/ : {
        *(.eh_frame)
    }
}
```

第 1 行我们设置了目标平台为 riscv ；.

第 2 行我们设置了整个程序的入口点为之前定义的全局符号 `_start`；

第 3 行定义了一个常量 `BASE_ADDRESS` 为 `0x80200000` ，也就是我们之前提到内核的初始化代码被放置的地址；

从第 5 行开始体现了链接过程中对输入的目标文件的段的合并。其中 `.` 表示当前地址，也就是链接器会从它指向的位置开始往下放置从输入的目标文件中收集来的段。我们可以对 `.` 进行赋值来调整接下来的段放在哪里，也可以创建一些全局符号赋值为 `.` 从而记录这一时刻的位置。我们还能够看到这样的格式：

```assembly
.rodata : {
    *(.rodata)
}
```

冒号前面表示最终生成的可执行文件的一个段的名字，花括号内按照放置顺序描述将所有输入目标文件的哪些段放在这个段中，每一行格式为 `<ObjectFile>(SectionName)`，表示目标文件 `ObjectFile` 的名为 `SectionName` 的段需要被放进去。我们也可以使用通配符来书写 `<ObjectFile>` 和 `<SectionName>` 分别表示可能的输入目标文件和段名。因此，最终的合并结果是，在最终可执行文件中各个常见的段 `.text, .rodata .data, .bss` 从低地址到高地址按顺序放置，每个段里面都包括了所有输入目标文件的同名段，且每个段都有两个全局符号给出了它的开始和结束地址（比如 `.text` 段的开始和结束地址分别是 `stext` 和 `etext` ）。

第 12 行我们将包含内核第一条指令的 `.text.entry` 段放在最终的 `.text` 段的最开头，同时注意到在最终内存布局中代码段 `.text` 又是先于任何其他段的。因为所有的段都从 `BASE_ADDRESS` 也即 `0x80200000` 开始放置，这就能够保证内核的第一条指令正好放在 `0x80200000` 从而能够正确对接到 Qemu 上。

此后我们便可以生成内核可执行文件，切换到 `os` 目录下并进行以下操作：

```rust
cargo build --release
```

 **0x80200000 可否改为其他地址？**:如果一个程序全程都使用相对地址而不依赖任何绝对地址，我们可以将程序在内存中随意平移。这种程序被称为 **位置无关可执行文件（PIE，Position-independent Executable）** 。由于我们的内核并不是位置无关的，所以我们必须将内存布局的起始地址设置为 `0x80200000` ，与之匹配我们也必须将内核加载到这一地址。

### 手动加载内核可执行文件

上面得到的内核可执行文件完全符合我们对于内存布局的要求，但是我们不能将其直接提交给 Qemu ，因为它除了实际会被用到的代码和数据段之外还有一些多余的元数据，这些元数据无法被 Qemu 在加载文件时利用，且会使代码和数据段被加载到错误的位置。如下图所示：

<img src="./assets/image-20230527175439930.png" alt="image-20230527175439930" style="zoom: 50%;" />

图中，红色的区域表示内核可执行文件中的元数据，深蓝色的区域表示各个段（包括代码段和数据段），而浅蓝色区域则表示内核被执行的第一条指令，它位于深蓝色区域的开头。图示的上半部分中，我们直接将内核可执行文件 `os` 提交给 Qemu ，而 Qemu 会将整个可执行文件不加处理的加载到 Qemu 内存的 `0x80200000` 处，由于内核可执行文件的开头是一段元数据，这会导致 Qemu 内存 `0x80200000` 处无法找到内核第一条指令，也就意味着 RustSBI 无法正常将计算机控制权转交给内核。相反，图示的下半部分中，将元数据丢弃得到的内核镜像 `os.bin` 被加载到 Qemu 之后，则可以在 `0x80200000` 处正确找到内核第一条指令。

使用如下命令可以丢弃内核可执行文件中的元数据得到内核镜像：

```
rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin
```

比较内核可执行文件和内核镜像的大小：

```
stat target/riscv64gc-unknown-none-elf/release/os
stat target/riscv64gc-unknown-none-elf/release/os.bin
```

一般情况下 RISC-V 架构的一条指令位宽即为 4 字节。而内核可执行文件由于包含了两部分元数据，其大小达到了 1016 字节。这些元数据能够帮助我们更加灵活地加载并使用可执行文件，比如在加载时完成一些重定位工作或者动态链接。不过由于 Qemu 的加载功能过于简单，我们只能将这些元数据丢弃再交给 Qemu 。从某种意义上可以理解为我们手动帮助 Qemu 完成了可执行文件的加载。

### 基于 GDB 验证启动流程

在 `os` 目录下通过以下命令启动 Qemu 并加载 RustSBI 和内核镜像：

```shell
qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios ../bootloader/rustsbi-qemu.bin \
    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \
    -s -S
```

`-s` 可以使 Qemu 监听本地 TCP 端口 1234 等待 GDB 客户端连接，而 `-S` 可以使 Qemu 在收到 GDB 的请求后再开始运行。因此，Qemu 暂时没有任何输出。注意，如果不想通过 GDB 对于 Qemu 进行调试而是直接运行 Qemu 的话，则要删掉最后一行的 `-s -S` 。

打开另一个终端，启动一个 GDB 客户端连接到 Qemu ：

```shell
riscv64-unknown-elf-gdb \
    -ex 'file target/riscv64gc-unknown-none-elf/release/os' \
    -ex 'set arch riscv:rv64' \
    -ex 'target remote localhost:1234'
```

可以看到，正如我们在上一节提到的那样，Qemu 启动后 PC 被初始化为 `0x1000` 。我们可以检查一下 Qemu 的启动固件的内容：

```
(gdb) x/10i $pc
=> 0x1000:  auipc   t0,0x0
0x1004:     addi    a1,t0,32
0x1008:     csrr    a0,mhartid
0x100c:     ld      t0,24(t0)
0x1010:     jr      t0
0x1014:     unimp
0x1016:     unimp
0x1018:     unimp
0x101a:     0x8000
0x101c:     unimp
```

这里 `x/10i $pc` 的含义是从当前 PC 值的位置开始，在内存中反汇编 10 条指令。不过可以看到 Qemu 的固件仅包含 5 条指令，从 `0x1014` 开始都是数据，当数据为 0 的时候则会被反汇编为 `unimp` 指令。 `0x101a` 处的数据 `0x8000` 是能够跳转到 `0x80000000` 进入启动下一阶段的关键。有兴趣的读者可以自行探究位于 `0x1000` 和 `0x100c` 两条指令的含义。总之，在执行位于 `0x1010` 的指令之前，寄存器 `t0` 的值恰好为 `0x80000000` ，随后通过 `jr t0` 便可以跳转到该地址。我们可以通过单步调试来复盘这个过程：

```
(gdb) si
0x0000000000001004 in ?? ()
(gdb) si
0x0000000000001008 in ?? ()
(gdb) si
0x000000000000100c in ?? ()
(gdb) si
0x0000000000001010 in ?? ()
(gdb) p/x $t0
1 = 0x80000000
(gdb) si
0x0000000080000000 in ?? ()
```

其中， `si` 可以让 Qemu 每次向下执行一条指令，之后屏幕会打印出待执行的下一条指令的地址。 `p/x $t0` 以 16 进制打印寄存器 `t0` 的值，注意当我们要打印寄存器的时候需要在寄存器的名字前面加上 `$` 。可以看到，当位于 `0x1010` 的指令执行完毕后，下一条待执行的指令位于 RustSBI 的入口，也即 `0x80000000` ，这意味着我们即将把控制权转交给 RustSBI 。

```
 x/10i $pc
=> 0x80000000:      auipc   sp,0x28
0x80000004: mv      sp,sp
0x80000008: lui     t0,0x4
0x8000000a: addi    t1,a0,1
0x8000000e: add     sp,sp,t0
0x80000010: addi    t1,t1,-1
0x80000012: bnez    t1,0x8000000e
0x80000016: j       0x8001125a
0x8000001a: unimp
0x8000001c: addi    sp,sp,-48
$ (gdb) si
0x0000000080000004 in ?? ()
$ (gdb) si
0x0000000080000008 in ?? ()
$ (gdb) si
0x000000008000000a in ?? ()
$ (gdb) si
0x000000008000000e in ?? ()
```

我们可以用同样的方式反汇编 RustSBI 最初的几条指令并单步调试。不过由于 RustSBI 超出了本书的范围，我们这里并不打算进行深入。接下来我们检查控制权能否被移交给我们的内核：

```
$ (gdb) b *0x80200000
Breakpoint 1 at 0x80200000
$ (gdb) c
Continuing.

Breakpoint 1, 0x0000000080200000 in ?? ()
```

我们在内核的入口点，也即地址 `0x80200000` 处打一个断点。需要注意，当需要在一个特定的地址打断点时，需要在地址前面加上 `*` 。接下来通过 `c` 命令（Continue 的缩写）让 Qemu 向下运行直到遇到一个断点。可以看到，我们成功停在了 `0x80200000` 处。随后，可以检查内核第一条指令是否被正确执行：

```
(gdb) x/5i $pc
=> 0x80200000:      li      ra,100
0x80200004: unimp
0x80200006: unimp
0x80200008: unimp
0x8020000a: unimp
$ (gdb) si
0x0000000080200004 in ?? ()
$ (gdb) p/d $x1
$2 = 100
$ (gdb) p/x $sp
$3 = 0x0
```

可以看到我们在 `entry.asm` 中编写的第一条指令可以在 `0x80200000` 处找到。这里 `ra` 是寄存器 `x1` 的别名， `p/d $x1` 可以以十进制打印寄存器 `x1` 的值，它的结果正确。最后，作为下一节的铺垫，我们可以检查此时栈指针 `sp` 的值，可以发现它目前是 0 。下一节我们将设置好栈空间，使得内核代码可以正常进行函数调用，随后将控制权转交给 Rust 代码。

## 为内核支持函数调用

不过为了将控制权转交给我们使用 Rust 语言编写的内核入口函数，我们确实需要手写若干行汇编代码进行一定的初始化工作。和之前一样，这些汇编代码放在 `entry.asm` 中，并在控制权被转交给内核相关函数前最先被执行，但它们的功能会更加复杂。

首先需要设置栈空间，来在内核内使能函数调用，

随后直接调用使用 Rust 编写的内核入口函数，

从而控制权便被移交给 Rust 代码。

这就是构建“三叶虫”操作系统的第三个步骤。

### 函数调用与栈

从汇编指令的级别看待一段程序的执行，假如 CPU 依次执行的指令的物理地址序列为 $\{a_n\}$,

最简单的无疑就是 CPU 一条条连续向下执行指令，也即满足递推公式 $a_{n+1}=a_n+L$

这里我们假设该平台的指令是定长的且均为 $L$ 字节（常见情况为 2/4 字节）.

当$a_n$为跳转指令时这个规律将会被打破，比如控制流，if，while等

更为复杂的控制流， **函数调用** (Function Call)

首先在调用的时候，需要有一条指令跳转到被调用函数的位置，这个看起来和其他控制结构没什么不同；但是在被调用函数返回的时候，我们却需要返回那条跳转过来的指令的下一条继续执行。这次用来返回的跳转究竟跳转到何处，在对应的函数调用发生之前是不知道的。比如，我们在两个不同的地方调用同一个函数，显然函数返回之后会回到不同的地址。这是一个很大的不同：其他控制流都只需要跳转到一个 *编译期固定下来* 的地址，而函数调用的返回跳转是跳转到一个 *运行时确定* （确切地说是在函数调用发生的时候）的地址。

![image-20230528143026330](./assets/image-20230528143026330.png)

对此，指令集必须给用于函数调用的跳转指令一些额外的能力，而不只是单纯的跳转。在 RISC-V 架构上，有两条指令即符合这样的特征：

![image-20230528143055625](./assets/image-20230528143055625.png)

这两条指令在设置 pc 寄存器完成跳转功能之前，还将当前跳转指令的下一条指令地址保存在 rd 寄存器中，即$ rd\gets pc+4 $这条指令的含义。

事实上在函数返回的时候我们常常使用一条 **汇编伪指令** (Pseudo Instruction) 跳转回调用之前的位置： `ret` 。它会被汇编器翻译为 `jalr x0, 0(x1)`，含义为跳转到寄存器 `ra` 保存的物理地址，由于 `x0` 是一个恒为 `0` 的寄存器，在 `rd` 中保存这一步被省略。

总结一下，在进行函数调用的时候，我们通过 `jalr` 指令保存返回地址并实现跳转；而在函数即将返回的时候，则通过 `ret` 伪指令回到跳转之前的下一条指令继续执行。这样，RISC-V 的这两条指令就实现了函数调用流程的核心机制。

我们将由于函数调用，在控制流转移前后需要保持不变的寄存器集合称之为 **函数调用上下文** (Function Call Context) 。

我们需要在物理内存中的一个区域 **保存** (Save) 函数调用上下文中的寄存器；而在函数执行完毕后，我们会从内存中同样的区域读取并 **恢复** (Restore) 函数调用上下文中的寄存器。

- **被调用者保存(Callee-Saved) 寄存器** ：被调用的函数可能会覆盖这些寄存器，需要被调用的函数来保存的寄存器，即由被调用的函数来保证在调用前后，这些寄存器保持不变；
- **调用者保存(Caller-Saved) 寄存器** ：被调用的函数可能会覆盖这些寄存器，需要发起调用的函数来保存的寄存器，即由发起调用的函数来保证在调用前后，这些寄存器保持不变。

我们并没有详细说明这些寄存器保存在哪里，只是用“内存中的一块区域”草草带过。实际上，它更确切的名字是 **栈** (Stack) 。 `sp` 寄存器常用来保存 **栈指针** (Stack Pointer)，它指向内存中栈顶地址。在 RISC-V 架构中，栈是从高地址向低地址增长的。在一个函数中，作为起始的开场代码负责分配一块新的栈空间，即将 `sp` 的值减小相应的字节数即可，于是物理地址区间 新旧[新sp,旧sp) 对应的物理内存的一部分便可以被这个函数用来进行函数调用上下文的保存/恢复，这块物理内存被称为这个函数的 **栈帧** (Stack Frame)。同理，函数中的结尾代码负责将开场代码分配的栈帧回收，这也仅仅需要将 `sp` 的值增加相同的字节数回到分配之前的状态。这也可以解释为什么 `sp` 是一个被调用者保存寄存器。

栈上多个 `fp` 信息实际上保存了一条完整的函数调用链，通过适当的方式我们可以实现对函数调用关系的跟踪。

`ra` 、 `sp` 和 `fp` 是和函数调用紧密相关的寄存器，我们用一个例子来展示真实编译器生成的汇编代码会如何使用这些寄存器。首先，无论对于内核本身还是第二章后出现的应用程序，我们修改 `.cargo/config` :

```toml
// .cargo/config

[build]
target = "riscv64gc-unknown-none-elf"

[target.riscv64gc-unknown-none-elf]
rustflags = [
    "-Clink-args=-Tsrc/linker.ld", "-Cforce-frame-pointers=yes"
]
```

### 分配并使用启动栈

我们在 `entry.asm` 中分配启动栈空间，并在控制权被转交给 Rust 入口之前将栈指针 `sp` 设置为栈顶的位置。

```assembly
# os/src/entry.asm
    .section .text.entry
    .globl _start
_start:
    la sp, boot_stack_top
    call rust_main

    .section .bss.stack
    .globl boot_stack_lower_bound
boot_stack_lower_bound:
    .space 4096 * 16
    .globl boot_stack_top
boot_stack_top:
```

我们在第 11 行在内核的内存布局中预留了一块大小为 4096 * 16 字节也就是 64KiB 的空间用作接下来要运行的程序的栈空间。

![image-20230528154418012](./assets/image-20230528154418012.png)

第 8 行可以看到我们将这块空间放置在一个名为 `.bss.stack` 的段中，在链接脚本 `linker.ld` 中可以看到 `.bss.stack` 段最终会被汇集到 `.bss` 段中：

```
.bss : {
    *(.bss.stack)
    sbss = .;
    *(.bss .bss.*)
    *(.sbss .sbss.*)
}
ebss = .;
```

回到 `entry.asm` ，可以发现在控制权转交给 Rust 入口之前会执行两条指令，它们分别位于 `entry.asm` 的第 5、6 行。

第 6 行我们通过伪指令 `call` 调用 Rust 编写的内核入口点 `rust_main` 将控制权转交给 Rust 代码，该入口点在 `main.rs` 中实现：

```rust
// os/src/main.rs
#[no_mangle]
pub fn rust_main() -> ! {
    loop {}
}
```

这里需要注意的是需要通过宏将 `rust_main` 标记为 `#[no_mangle]` 以避免编译器对它的名字进行混淆，不然在链接的时候， `entry.asm` 将找不到 `main.rs` 提供的外部符号 `rust_main` 从而导致链接失败。

在内核初始化中，需要先完成对 `.bss` 段的清零。这是内核很重要的一部分初始化工作，在使用任何被分配到 `.bss` 段的全局变量之前我们需要确保 `.bss` 段已被清零。我们就在 `rust_main` 的开头完成这一工作，由于控制权已经被转交给 Rust ，我们终于不用手写汇编代码而是可以用 Rust 来实现这一功能了：

```rust
// os/src/main.rs
#[no_mangle]
pub fn rust_main() -> ! {
    clear_bss();
    loop {}
}

fn clear_bss() {
    extern "C" {
        fn sbss();
        fn ebss();
    }
    (sbss as usize..ebss as usize).for_each(|a| {
        unsafe { (a as *mut u8).write_volatile(0) }
    });
}
```

在函数 `clear_bss` 中，我们会尝试从其他地方找到全局符号 `sbss` 和 `ebss` ，它们由链接脚本 `linker.ld` 给出，并分别指出需要被清零的 `.bss` 段的起始和终止地址。接下来我们只需遍历该地址区间并逐字节进行清零即可。

==本节我们介绍了函数调用和栈的背景知识，通过分配栈空间并正确设置栈指针在内核中使能了函数调用并成功将控制权转交给 Rust 代码，从此我们终于可以利用强大的 Rust 语言来编写内核的各项功能了。==



## 基于 SBI 服务完成输出和关机

进行构建“三叶虫”操作系统的最后一个步骤，即基于 RustSBI 提供的服务完成在屏幕上打印 `Hello world!` 和关机操作。

RustSBI 介于底层硬件和内核之间，是我们内核的底层执行环境。

本节将会提到执行环境除了为上层应用进行初始化的第二种职责：即在上层应用运行时提供服务。

本节的代码涉及的汇编和 Rust 的细节较多，不必完全理解其含义，重点在于将内核成功运行起来。

### 使用 RustSBI 提供的服务

当内核发出请求时，计算机会转由 RustSBI 控制来响应内核的请求，待请求处理完毕后，计算机控制权会被交还给内核。

在main中引入：

```
// os/src/main.rs
mod sbi;
```

编写sbi

```rust
// os/src/sbi.rs
use core::arch::asm;
#[inline(always)]
fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> usize {
    let mut ret;
    unsafe {
        asm!(
            "ecall",
            inlateout("x10") arg0 => ret,
            in("x11") arg1,
            in("x12") arg2,
            in("x17") which,
        );
    }
    ret
}

```

我们首先关注 `sbi_call` 的函数签名， `which` 表示请求 RustSBI 的服务的类型（RustSBI 可以提供多种不同类型的服务）， `arg0` ~ `arg2` 表示传递给 RustSBI 的 3 个参数，而 RustSBI 在将请求处理完毕后，会给内核一个返回值，这个返回值也会被 `sbi_call` 函数返回。尽管我们还不太理解函数 `sbi_call` 的具体实现，但目前我们已经知道如何使用它了：当需要使用 RustSBI 服务的时候调用它就行了。

在 `sbi.rs` 中我们定义 RustSBI 支持的服务类型常量，它们并未被完全用到：

```rust
// os/src/sbi.rs
#![allow(unused)] // 此行请放在该文件最开头
const SBI_SET_TIMER: usize = 0;
const SBI_CONSOLE_PUTCHAR: usize = 1;
const SBI_CONSOLE_GETCHAR: usize = 2;
const SBI_CLEAR_IPI: usize = 3;
const SBI_SEND_IPI: usize = 4;
const SBI_REMOTE_FENCE_I: usize = 5;
const SBI_REMOTE_SFENCE_VMA: usize = 6;
const SBI_REMOTE_SFENCE_VMA_ASID: usize = 7;
const SBI_SHUTDOWN: usize = 8;
```

如字面意思，服务 `SBI_CONSOLE_PUTCHAR` 可以用来在屏幕上输出一个字符。我们将这个功能封装成 `console_putchar` 函数：

```rust
// os/src/sbi.rs
pub fn console_putchar(c: usize) {
    sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0);
}
```

接着在 Qemu 上运行一下，我们便可看到由我们自己输出的第一条 log 了。

类似上述方式，我们还可以将关机服务 `SBI_SHUTDOWN` 封装成 `shutdown` 函数：

```rust
// os/src/sbi.rs
pub fn shutdown() -> ! {
    sbi_call(SBI_SHUTDOWN, 0, 0, 0);
    panic!("It should shutdown!");
}
```

最新版RustSBI使用以下实现：

```rust
//src/sbi.rs

use core::arch::asm;
#[allow(unused)]

// legacy extensions: ignore fid
const SBI_SET_TIMER: usize = 0;
const SBI_CONSOLE_PUTCHAR: usize = 1;
const SBI_CONSOLE_GETCHAR: usize = 2;
const SBI_CLEAR_IPI: usize = 3;
const SBI_SEND_IPI: usize = 4;
const SBI_REMOTE_FENCE_I: usize = 5;
const SBI_REMOTE_SFENCE_VMA: usize = 6;
const SBI_REMOTE_SFENCE_VMA_ASID: usize = 7;

// system reset extension
const SRST_EXTENSION: usize = 0x53525354;
const SBI_SHUTDOWN: usize = 0;

#[inline(always)]
fn sbi_call(eid: usize, fid: usize, arg0: usize, arg1: usize, arg2: usize) -> usize {
    let mut ret;
    unsafe {
        asm!(
            "ecall",
            inlateout("x10") arg0 => ret,
            in("x11") arg1,
            in("x12") arg2,
            in("x16") fid,
            in("x17") eid,
        );
    }
    ret
}

pub fn console_putchar(c: usize) {
    sbi_call(SBI_CONSOLE_PUTCHAR, 0, c, 0, 0);
}

pub fn shutdown() -> ! {
    sbi_call(SRST_EXTENSION, SBI_SHUTDOWN, 0, 0, 0);
    panic!("It should shutdown!")
}
```



### 实现格式化输出

`console_putchar` 的功能过于受限，如果想打印一行 `Hello world!` 的话需要进行多次调用。

因此我们尝试自己编写基于 `console_putchar` 的 `println!` 宏。

main中

```rust
// os/src/main.rs
#[macro_use]
mod console;
```

console中

```rust
// os/src/console.rs
use crate::sbi::console_putchar;
use core::fmt::{self, Write};

struct Stdout;

impl Write for Stdout {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for c in s.chars() {
            console_putchar(c as usize);
        }
        Ok(())
    }
}

pub fn print(args: fmt::Arguments) {
    Stdout.write_fmt(args).unwrap();
}

#[macro_export]
macro_rules! print {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        $crate::console::print(format_args!($fmt $(, $($arg)+)?));
    }
}

#[macro_export]
macro_rules! println {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        $crate::console::print(format_args!(concat!($fmt, "\n") $(, $($arg)+)?));
    }
}
```

我们在 `console` 子模块中编写 `println!` 宏。结构体 `Stdout` 不包含任何字段，

`ore::fmt::Write` trait 包含一个用来实现 `println!` 宏很好用的 `write_fmt` 方法，为此我们准备为结构体 `Stdout` 实现 `Write` trait 。在 `Write` trait 中， `write_str` 方法必须实现，因此我们需要为 `Stdout` 实现这一方法，它并不难实现，只需遍历传入的 `&str` 中的每个字符并调用 `console_putchar` 就能将传入的整个字符串打印到屏幕上。

### 处理致命错误

这里我们主要关心不可恢复错误。

此前：

```rust
// os/src/lang_items.rs
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

可以看到，在目前的实现中，当遇到不可恢复错误的时候，被标记为语义项 `#[panic_handler]` 的 `panic` 函数将会被调用，然而其中只是一个死循环，会使得计算机卡在这里。借助前面实现的 `println!` 宏和 `shutdown` 函数，我们可以在 `panic` 函数中打印错误信息并关机：

```rust
// os/src/lang_item.rs
use crate::sbi::shutdown;
use core::panic::PanicInfo;

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    if let Some(location) = info.location() {
        println!(
            "Panicked at {}:{} {}",
            location.file(),
            location.line(),
            info.message().unwrap()
        );
    } else {
        println!("Panicked: {}", info.message().unwrap());
    }
    shutdown()
}
```

我们尝试打印更加详细的信息，包括 panic 所在的源文件和代码行数。我们尝试从传入的 `PanicInfo` 中解析这些信息，如果解析成功的话，就和 panic 的报错信息一起打印出来。我们需要在 `main.rs` 开头加上 `#![feature(panic_info_message)]` 才能通过 `PanicInfo::message` 获取报错信息。当打印完毕之后，我们直接调用 `shutdown` 函数关机。

测试：

```rust
#![no_main]
#![no_std]
#![feature(panic_info_message)]
#[macro_use]

mod console;
mod lang_items;
mod sbi;
use core::arch::global_asm;
global_asm!(include_str!("entry.asm"));
#[no_mangle]
pub fn rust_main() -> ! {
    clear_bss();
    println!("hello world!");
    panic!("Shutdown machine!")
}
fn clear_bss() {
    extern "C" {
        fn sbss();
        fn ebss();
    }
    (sbss as usize..ebss as usize).for_each(|a| {
        unsafe { (a as *mut u8).write_volatile(0) }
    });
}

```

一个简单的脚本

```sh
cd os && cargo build --release
rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin
qemu-system-riscv64 -machine virt -nographic -bios ../bootloader/rustsbi-qemu.bin -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000
```

到这里，我们就实现了一个可以在Qemu模拟的计算机上运行的裸机应用程序，其具体内容就是上述的 rust_main`函数，而其他部分，如 `entry.asm 、 lang_items.rs 、console.rs 、 sbi.rs 则形成了支持裸机应用程序的寒武纪“三叶虫”操作系统 – LibOS 。



## 练习

输出ERROR信息：

```rust
#[macro_export]
macro_rules! ERROR{
    ($fmt: literal $(, $($arg: tt)+)?) => {
        $crate::console::print(format_args!("[ERROR][0] {}{}{}\n", "\x1b[31m" , format_args!($fmt $(, $($arg)+)?), "\x1b[0m"));
    }
}
```



# 第二章 批处理

## 引言

需要操作系统能够终止出错的应用程序，转而运行下一个应用程序。这种 *保护* 计算机系统不受有意或无意出错的程序破坏的机制被称为 **特权级** (Privilege) 机制，它让应用程序运行在用户态，而操作系统运行在内核态，且实现用户态和内核态的隔离，这需要计算机软件和硬件的共同努力。

一个简单两级保护环（用户态和内核态）再加上分页机制，就足以实现绝大多数的安全隔离需求了。

本章主要是设计和实现建立支持批处理系统的泥盆纪“邓式鱼”操作系统，从而对可支持运行一批应用程序的执行环境有一个全面和深入的理解。

让操作系统能够感知多个应用程序的存在，并一个接一个地运行这些应用程序，当一个应用程序执行完毕后，会启动下一个应用程序，直到所有的应用程序都执行完毕。

体验

```
git clone https://github.com/rcore-os/rCore-Tutorial-v3.git
cd rCore-Tutorial-v3
git checkout ch2
cd os
make run
```



## 特权机制

实现特权级机制的根本原因是应用程序运行的安全性不可充分信任。



通常的函数调用方法`call;ret`会绕过特权检查；所以设置新的机器指令：

- 执行环境调用（Execution Environment Call，简称 `ecall` ）：用户态到内核态
- 执行环境返回(Execution Environment Return，简称 `eret` )：内核态到用户态

x86 和 RISC-V 设计了多达 4 种特权级，而对于一般的操作系统而言，其实只要两种特权级就够了。

| 级别 | 编码 | 名称                                |
| ---- | ---- | ----------------------------------- |
| 0    | 00   | 用户/应用模式 (U, User/Application) |
| 1    | 01   | 监督模式 (S, Supervisor)            |
| 2    | 10   | 虚拟监督模式 (H, Hypervisor)        |
| 3    | 11   | 机器模式 (M, Machine)               |

在硬件层面，只有M是必须的。

![image-20230606113332155](./assets/image-20230606113332155.png)

白色块表示一层**执行环境**，黑色块表示相邻两层执行**环境之间的接口**。

APP运行在U模型；OS运行在S模式；SEE运行在M模式；

本书实现了M/S/U三种模式；

第一章提到的预编译的 bootloader – `RustSBI` 实际上是运行在更底层的 M 模式特权级下的软件，是操作系统内核的执行环境

S模式与M模式的接口被称为： **监督模式二进制接口**SBI

U模式与S模式的接口被称为： **应用程序二进制接口**ABI，或者叫做**系统调用**syscall, System Call

模式切换

<img src="./assets/image-20230606134432310.png" alt="image-20230606134432310" style="zoom:50%;" />

### RSIC-V特权指令

与特权级无关的一般的指令和通用寄存器 `x0` ~ `x31` 在任何特权级都可以执行。

每个特权级都对应一些特殊指令和 **控制状态寄存器** (CSR, Control and Status Register) ，来控制该特权级的某些行为并描述其状态。

在 RISC-V 中，会有两类属于高特权级 S 模式的特权指令：

- 指令本身属于高特权级的指令，如 `sret` 指令（表示从 S 模式返回到 U 模式）。
- 指令访问了 S模式特权级下才能访问的寄存器或内存，如表示S模式系统状态的 **控制状态寄存器** `sstatus` 等。



## 实现应用程序

本节主要实现 批处理系统 加载并执行应用程序，假定在U模式下运行。

实现要点：

- 应用程序的内存布局
- 应用程序发出的系统调用

### 应用程序设计

```
├── Cargo.toml
├── Makefile
├── src
│   ├── bin
│   │   ├── 00hello_world.rs
│   │   ├── 01store_fault.rs
│   │   ├── 02power.rs
│   │   ├── 03priv_inst.rs
│   │   └── 04priv_csr.rs
│   ├── console.rs
│   ├── lang_items.rs
│   ├── lib.rs
│   ├── linker.ld
│   └── syscall.rs
└── target
```

与之前相比主要区别在于目录结构与内存布局上有不同：

- `user/src/bin/*.rs` ：各个应用程序
- `user/src/*.rs` ：用户库（包括入口函数、初始化函数、I/O 函数和系统调用接口等）
- `user/src/linker.ld` ：应用程序的内存布局说明。

#### 项目结构

`user/src` 目录下面`bin` 里面有多个文件，目前里面至少有三个程序（一个文件是一个应用程序），分别是：

- `hello_world` ：在屏幕上打印一行 `Hello world from user mode program!`

    ```go
    #![no_std]
    #![no_main]
    
    #[macro_use]
    extern crate user_lib;
    
    #[no_mangle]
    fn main() -> i32 {
        println!("Hello, world!");
        0
    }
    ```

    

- `store_fault` ：访问一个非法的物理地址，测试批处理系统是否会被该错误影响

    ```go
    #![no_std]
    #![no_main]
    
    #[macro_use]
    extern crate user_lib;
    
    #[no_mangle]
    fn main() -> i32 {
        println!("Into Test store_fault, we will insert an invalid store operation...");
        println!("Kernel should kill this application!");
        unsafe {
            core::ptr::null_mut::<u8>().write_volatile(0);
        }
        0
    }
    ```

    

- `power` ：不断在计算操作和打印字符串操作之间进行特权级切换

    ```go
    #![no_std]
    #![no_main]
    
    #[macro_use]
    extern crate user_lib;
    
    const SIZE: usize = 10;
    const P: u32 = 3;
    const STEP: usize = 100000;
    const MOD: u32 = 10007;
    
    #[no_mangle]
    fn main() -> i32 {
        let mut pow = [0u32; SIZE];
        let mut index: usize = 0;
        pow[index] = 1;
        for i in 1..=STEP {
            let last = pow[index];
            index = (index + 1) % SIZE;
            pow[index] = last * P % MOD;
            if i % 10000 == 0 {
                println!("{}^{}={}(MOD {})", P, i, pow[index], MOD);
            }
        }
        println!("Test power OK!");
        0
    }
    ```

- `03priv_inst`

    ```rust
    #![no_std]
    #![no_main]
    
    #[macro_use]
    extern crate user_lib;
    
    use core::arch::asm;
    
    #[no_mangle]
    fn main() -> i32 {
        println!("Try to execute privileged instruction in U Mode");
        println!("Kernel should kill this application!");
        unsafe {
            asm!("sret");
        }
        0
    }
    ```

- `04priv_csr`

    ```rust
    #![no_std]
    #![no_main]
    
    #[macro_use]
    extern crate user_lib;
    
    use riscv::register::sstatus::{self, SPP};
    
    #[no_mangle]
    fn main() -> i32 {
        println!("Try to access privileged CSR in U Mode");
        println!("Kernel should kill this application!");
        unsafe {
            sstatus::set_spp(SPP::User);
        }
        0
    }
    ```

    

批处理系统会按照文件名开头的数字编号从小到大的顺序加载并运行它们。

应用程序外部库的引入：

```go
#[macro_use]
extern crate user_lib;
```

为什么叫`user_lib`?在配置文件中`name = "user_lib"`;`user/Cargo.toml`内容如下：

```toml
[package]
name = "user_lib"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
riscv = { git = "https://github.com/rcore-os/riscv", features = ["inline-asm"] } 

[profile.release]
debug = true
```

在lib中定义用户库的入口`user/src/lib.rs`:

```rust
#![no_std]
#![feature(linkage)]
#![feature(panic_info_message)]

#[macro_use]
pub mod console;
mod lang_items;
mod syscall;


use syscall::*;

pub fn write(fd: usize,buf: &[u8]) -> isize{sys_write(fd,buf)}
pub fn exit(exit_code:i32)->isize{sys_exit(exit_code)}

#[no_mangle]
#[link_section = ".text.entry"]
pub extern "C" fn _start() ->!{
    clear_bss();
    exit(main());
    panic!("unreachable after sys_exit!");
}

#[linkage = "weak"]
#[no_mangle]
fn main() -> i32 {
    panic!("Cannot find main!");
}


fn clear_bss() {
    extern "C" {
        fn start_bss();
        fn end_bss();
    }
    (start_bss as usize..end_bss as usize).for_each(|addr| unsafe {
        (addr as *mut u8).write_volatile(0);
    });
}
```

 Rust 的宏将 `_start` 这段代码编译后的汇编代码中放在一个名为 `.text.entry` 的代码段中，方便我们在后续链接的时候调整它的位置使得它能够作为用户库的入口。

进入用户库入口之后，首先和第一章一样，手动清空需要零初始化的 `.bss` 段

这段代码中的另一个main。使用 Rust 的宏将其函数符号 `main` 标志为弱链接。这样在最后链接的时候，虽然在 `lib.rs` 和 `bin` 目录下的某个应用程序都有 `main` 符号，但由于 `lib.rs` 中的 `main` 符号是弱链接，链接器会使用 `bin` 目录下的应用主逻辑作为 `main` 。这里我们主要是进行某种程度上的保护，如果在 `bin` 目录下找不到任何 `main` ，那么编译也能够通过，但会在运行时报错。

为了支持上述这些链接操作，我们需要在 `lib.rs` 的开头加入：

```rust
#![feature(linkage)]
```

#### 内存布局

在 `user/.cargo/config` 中，我们和第一章一样设置链接时使用链接脚本 `user/src/linker.ld` 。在其中我们做的重要的事情是：

- 将程序的起始物理地址调整为 `0x80400000` ，三个应用程序都会被加载到这个物理地址上运行；

    ```
    BASE_ADDRESS = 0x80400000;
    ```

    

- 将 `_start` 所在的 `.text.entry` 放在整个程序的开头，也就是说批处理系统只要在加载之后跳转到 `0x80400000` 就已经进入了 用户库的入口点，并会在初始化之后跳转到应用程序主逻辑；

    ```
    . = BASE_ADDRESS;
    .text : {
        *(.text.entry)
        *(.text .text.*)
    }
    ```

    

- 提供了最终生成可执行文件的 `.bss` 段的起始和终止地址，方便 `clear_bss` 函数使用。

    ```
    .bss : {
        start_bss = .;
        *(.bss .bss.*)
        *(.sbss .sbss.*)
        end_bss = .;
    }
    ```

    

完整代码`user/src/linker.ld`:

```
OUTPUT_ARCH(riscv)
ENTRY(_start)
BASE_ADDRESS = 0x80400000;

SECTIONS
{
    . = BASE_ADDRESS;
    .text : {
        *(.text.entry)
        *(.text .text.*)
    }

    .rodata : {
        *(.rodata .rodata.*)
        *(.srodata .srodata.*)
    }

    .data : {
        *(.data .data.*)
        *(.sdata .sdata.*)
    }

    .bss : {
        start_bss = .;
        *(.bss .bss.*)
        *(.sbss .sbss.*)
        end_bss = .;
    }

    /DISCARD/ : {
        *(.eh_frame)
        *(.debug*)
    }
}

```

#### 系统调用

在子模块 `syscall` 中，应用程序通过 `ecall` 调用批处理系统提供的接口，由于应用程序运行在用户态（即 U 模式）， `ecall` 指令会触发 名为 *Environment call from U-mode* 的异常，并 Trap 进入 S 模式执行批处理系统针对这个异常特别提供的服务代码。

在本章中，应用程序和批处理系统之间按照 API 的结构，约定如下两个系统调用：

```rust
/// 功能：将内存中缓冲区中的数据写入文件。
/// 参数：`fd` 表示待写入文件的文件描述符；
///      `buf` 表示内存中缓冲区的起始地址；
///      `len` 表示内存中缓冲区的长度。
/// 返回值：返回成功写入的长度。
/// syscall ID：64
fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize;

/// 功能：退出应用程序并将返回值告知批处理系统。
/// 参数：`exit_code` 表示应用程序的返回值。
/// 返回值：该系统调用不应该返回。
/// syscall ID：93
fn sys_exit(exit_code: usize) -> !;
```

系统调用实际上是汇编指令级的二进制接口，因此这里给出的只是使用 Rust 语言描述的 API 版本。在实际调用的时候，我们需要按照 RISC-V 调用规范（即ABI格式）在合适的寄存器中放置系统调用的参数，然后执行 `ecall` 指令触发 Trap。在 Trap 回到 U 模式的应用程序代码之后，会从 `ecall` 的下一条指令继续执行，同时我们能够按照调用规范在合适的寄存器中读取返回值。

**RISC-V 寄存器编号和别名**

RISC-V 寄存器编号从 `0~31` ，表示为 `x0~x31` 。 其中：

- `x10~x17` : 对应 `a0~a7`
- `x1` ：对应 `ra`

在 RISC-V 调用规范中，和函数调用的 ABI 情形类似，约定寄存器 `a0~a6` 保存系统调用的参数， `a0` 保存系统调用的返回值。有些许不同的是寄存器 `a7` 用来传递 syscall ID，这是因为所有的 syscall 都是通过 `ecall` 指令触发的，除了各输入参数之外我们还额外需要一个寄存器来保存要请求哪个系统调用。由于这超出了 Rust 语言的表达能力，我们需要在代码中使用内嵌汇编来完成参数/返回值绑定和 `ecall` 指令的插入：

```rust
// user/src/syscall.rs
use core::arch::asm;
fn syscall(id: usize, args: [usize; 3]) -> isize {
    let mut ret: isize;
    unsafe {
        asm!(
            "ecall",
            inlateout("x10") args[0] => ret,
            in("x11") args[1],
            in("x12") args[2],
            in("x17") id
        );
    }
    ret
}
```

将所有的系统调用都封装成 `syscall` 函数

相比 `global_asm!` ， `asm!` 宏可以获取上下文中的变量信息并允许嵌入的汇编代码对这些变量进行操作。

于是 `sys_write` 和 `sys_exit` 只需将 `syscall` 进行包装：

```rust
use core::arch::asm;
const SYSCALL_WRITE: usize = 64;
const SYSCALL_EXIT: usize = 93;

fn syscall(id: usize, args: [usize;3])->isize{
    let mut ret: isize;
    unsafe{
        asm!(
            "ecall",
            inlateout("x10") args[0] => ret,
            in("x11") args[1],
            in("x12") args[2],
            in("x17") id,
        )
    }
    ret
}

pub fn sys_write(fd: usize, buffer: &[u8])-> isize{
    syscall(SYSCALL_WRITE,[fd,buffer.as_ptr() as usize,buffer.len()])
}

pub fn sys_exit(xstate: i32)->isize{
    syscall(SYSCALL_EXIT,[xstate as usize,0,0])
}
```

我们将上述两个系统调用在用户库 `user_lib` 中进一步封装，从而更加接近在 Linux 等平台的实际系统调用接口：

```rust
// user/src/lib.rs
use syscall::*;

pub fn write(fd: usize, buf: &[u8]) -> isize { sys_write(fd, buf) }
pub fn exit(exit_code: i32) -> isize { sys_exit(exit_code) }
```

我们把 `console` 子模块中 `Stdout::write_str` 改成基于 `write` 的实现，且传入的 `fd` 参数设置为 1，它代表标准输出， 也就是输出到屏幕。目前我们不需要考虑其他的 `fd` 选取情况。这样，应用程序的 `println!` 宏借助系统调用变得可用了。 参考下面的代码片段：

```rust
use super::write;
use core::fmt::{self, Write};

const STDOUT:usize =1;

struct Stdout;

impl Write for Stdout{
    fn write_str(&mut self, s: &str)->fmt::Result{
        write(STDOUT,s.as_bytes());
        Ok(())
    }
} 

pub fn print(args: fmt::Arguments) {
    Stdout.write_fmt(args).unwrap();
}

#[macro_export]
macro_rules! print {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        $crate::console::print(format_args!($fmt $(, $($arg)+)?));
    }
}

#[macro_export]
macro_rules! println {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        $crate::console::print(format_args!(concat!($fmt, "\n") $(, $($arg)+)?));
    }
}
```

`exit` 接口则在用户库中的 `_start` 内使用，当应用程序主逻辑 `main` 返回之后，使用它退出应用程序并将返回值告知 底层的批处理系统。

#### 编译生成应用程序二进制码

在`user`目录下执行`make build`，其中makefile文件内容为：

```makefile
TARGET := riscv64gc-unknown-none-elf
MODE := release
APP_DIR := src/bin
TARGET_DIR := target/$(TARGET)/$(MODE)
APPS := $(wildcard $(APP_DIR)/*.rs)
ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS))
BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS))

OBJDUMP := rust-objdump --arch-name=riscv64
OBJCOPY := rust-objcopy --binary-architecture=riscv64

elf:
	@cargo build --release

binary: elf
	@$(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));)

build: binary
```

#### 实现操作系统前执行应用程序

通过`qemu-riscv64`,需要做到二者的系统调用的接口是一样的（包括系统调用编号，参数约定的具体的寄存器和栈等）

先看`user/src/bin/03_`与`04`

两个应用都会打印提示信息，随后应用 `03priv_inst` 会尝试在用户态执行内核态的特权指令 `sret` ，而应用 `04priv_csr` 则会试图在用户态修改内核态 CSR `sstatus` 。

```shell
cd user
make build
cd target/riscv64gc-unknown-none-elf/release/
确认待执行的应用为 ELF 格式
file 03priv_inst
03priv_inst: ELF 64-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped
执行特权指令出错
qemu-riscv64 ./03priv_inst
Try to execute privileged instruction in U Mode
Kernel should kill this application!
Illegal instruction (core dumped)
执行访问特权级 CSR 的指令出错
qemu-riscv64 ./04priv_csr
Try to access privileged CSR in U Mode
Kernel should kill this application!
Illegal instruction (core dumped)
```

对于普通程序

```shell
$ qemu-riscv64 ./00hello_world
Hello, world!
```

```shell
$ qemu-riscv64 ./01store_fault
Into Test store_fault, we will insert an invalid store operation...
Kernel should kill this application!
Segmentation fault (core dumped)
故意访问了一个非法地址，导致应用和 qemu-riscv64 被 Linux 内核杀死
$ qemu-riscv64 ./02power
3^10000=5079(MOD 10007)
3^20000=8202(MOD 10007)
3^30000=8824(MOD 10007)
3^40000=5750(MOD 10007)
3^50000=3824(MOD 10007)
3^60000=8516(MOD 10007)
3^70000=2510(MOD 10007)
3^80000=9379(MOD 10007)
3^90000=2621(MOD 10007)
3^100000=2749(MOD 10007)
Test power OK!
```

## 实现批处理操作系统

在批处理操作系统中，每当一个应用执行完毕，我们都需要将**下一个要执行的应用的代码和数据加载到内存**。

首先实现该==应用加载机制==。在操作系统和应用程序需要被放置到同一个可执行文件的前提下，设计一种尽量简洁的应用放置和加载方式，使得操作系统容易找到应用被放置到的位置，从而在批处理操作系统和应用程序之间建立起联系的纽带。具体而言，应用放置采用“静态绑定”的方式，而操作系统加载应用则采用“动态加载”的方式：

- 静态绑定：通过一定的编程技巧，把多个应用程序代码和批处理操作系统代码“绑定”在一起。
- 动态加载：基于静态编码留下的“绑定”信息，操作系统可以找到每个应用程序文件二进制代码的起始地址和长度，并能加载到内存中运行。

### 将应用程序链接到内核

我们把应用程序的二进制镜像文件（从 ELF 格式可执行文件剥离元数据，作为内核的数据段链接到内核里面，因此内核需要知道内含的应用程序的数量和它们的位置，这样才能够在运行时对它们进行管理并能够加载到物理内存。

在 `os/src/main.rs` 中能够找到这样一行：

```
global_asm!(include_str!("link_app.S"));
```

引入了一段汇编代码 `link_app.S` ，它一开始并不存在，而是在构建操作系统时自动生成的。当我们使用 `make run` 让系统运行的过程中，这个汇编代码 `link_app.S` 就生成了。我们可以先来看一看 `link_app.S` 里面的内容：

```assembly
# os/src/link_app.S

    .align 3
    .section .data
    .global _num_app
_num_app:
    .quad 5
    .quad app_0_start
    .quad app_1_start
    .quad app_2_start
    .quad app_3_start
    .quad app_4_start
    .quad app_4_end

    .section .data
    .global app_0_start
    .global app_0_end
app_0_start:
    .incbin "../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin"
app_0_end:

    .section .data
    .global app_1_start
    .global app_1_end
app_1_start:
    .incbin "../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin"
app_1_end:

    .section .data
    .global app_2_start
    .global app_2_end
app_2_start:
    .incbin "../user/target/riscv64gc-unknown-none-elf/release/02power.bin"
app_2_end:

    .section .data
    .global app_3_start
    .global app_3_end
app_3_start:
    .incbin "../user/target/riscv64gc-unknown-none-elf/release/03priv_inst.bin"
app_3_end:

    .section .data
    .global app_4_start
    .global app_4_end
app_4_start:
    .incbin "../user/target/riscv64gc-unknown-none-elf/release/04priv_csr.bin"
app_4_end:
```

可以看到第 15 行开始的五个数据段分别插入了五个应用程序的二进制镜像，并且各自有一对全局符号 `app_*_start, app_*_end` 指示它们的开始和结束位置。

这个文件是在 `cargo build` 的时候，由脚本 `os/build.rs` 控制生成的。

```go
use std::fs::{read_dir, File};
use std::io::{Result, Write};

fn main() {
    println!("cargo:rerun-if-changed=../user/src/");
    println!("cargo:rerun-if-changed={}", TARGET_PATH);
    insert_app_data().unwrap();
}

static TARGET_PATH: &str = "../user/target/riscv64gc-unknown-none-elf/release/";

fn insert_app_data() -> Result<()> {
    let mut f = File::create("src/link_app.S").unwrap();
    let mut apps: Vec<_> = read_dir("../user/src/bin")
        .unwrap()
        .into_iter()
        .map(|dir_entry| {
            let mut name_with_ext = dir_entry.unwrap().file_name().into_string().unwrap();
            name_with_ext.drain(name_with_ext.find('.').unwrap()..name_with_ext.len());
            name_with_ext
        })
        .collect();
    apps.sort();

    writeln!(
        f,
        r#"
    .align 3
    .section .data
    .global _num_app
_num_app:
    .quad {}"#,
        apps.len()
    )?;

    for i in 0..apps.len() {
        writeln!(f, r#"    .quad app_{}_start"#, i)?;
    }
    writeln!(f, r#"    .quad app_{}_end"#, apps.len() - 1)?;

    for (idx, app) in apps.iter().enumerate() {
        println!("app_{}: {}", idx, app);
        writeln!(
            f,
            r#"
    .section .data
    .global app_{0}_start
    .global app_{0}_end
app_{0}_start:
    .incbin "{2}{1}.bin"
app_{0}_end:"#,
            idx, app, TARGET_PATH
        )?;
    }
    Ok(())
}

```

